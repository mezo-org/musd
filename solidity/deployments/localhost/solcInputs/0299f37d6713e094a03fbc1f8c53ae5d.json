{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC5267.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC5267.sol)\n\npragma solidity ^0.8.20;\n\ninterface IERC5267 {\n    /**\n     * @dev MAY be emitted to signal that the domain could have changed.\n     */\n    event EIP712DomainChanged();\n\n    /**\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\n     * signature.\n     */\n    function eip712Domain()\n        external\n        view\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        );\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n\n    /**\n     * @dev The signature derives the `address(0)`.\n     */\n    error ECDSAInvalidSignature();\n\n    /**\n     * @dev The signature has an invalid length.\n     */\n    error ECDSAInvalidSignatureLength(uint256 length);\n\n    /**\n     * @dev The signature has an S value that is in the upper half order.\n     */\n    error ECDSAInvalidSignatureS(bytes32 s);\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\n     * and a bytes32 providing additional information about the error.\n     *\n     * If no error is returned, then the address can be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\n     */\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/EIP712.sol)\n\npragma solidity ^0.8.20;\n\nimport {MessageHashUtils} from \"./MessageHashUtils.sol\";\nimport {ShortStrings, ShortString} from \"../ShortStrings.sol\";\nimport {IERC5267} from \"../../interfaces/IERC5267.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding scheme specified in the EIP requires a domain separator and a hash of the typed structured data, whose\n * encoding is very generic and therefore its implementation in Solidity is not feasible, thus this contract\n * does not implement the encoding itself. Protocols need to implement the type-specific encoding they need in order to\n * produce the hash of their typed data using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * NOTE: In the upgradeable version of this contract, the cached values will correspond to the address, and the domain\n * separator of the implementation contract. This will cause the {_domainSeparatorV4} function to always rebuild the\n * separator from the immutable values, which is cheaper than accessing a cached version in cold storage.\n *\n * @custom:oz-upgrades-unsafe-allow state-variable-immutable\n */\nabstract contract EIP712 is IERC5267 {\n    using ShortStrings for *;\n\n    bytes32 private constant TYPE_HASH =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _cachedDomainSeparator;\n    uint256 private immutable _cachedChainId;\n    address private immutable _cachedThis;\n\n    bytes32 private immutable _hashedName;\n    bytes32 private immutable _hashedVersion;\n\n    ShortString private immutable _name;\n    ShortString private immutable _version;\n    string private _nameFallback;\n    string private _versionFallback;\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        _name = name.toShortStringWithFallback(_nameFallback);\n        _version = version.toShortStringWithFallback(_versionFallback);\n        _hashedName = keccak256(bytes(name));\n        _hashedVersion = keccak256(bytes(version));\n\n        _cachedChainId = block.chainid;\n        _cachedDomainSeparator = _buildDomainSeparator();\n        _cachedThis = address(this);\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _cachedThis && block.chainid == _cachedChainId) {\n            return _cachedDomainSeparator;\n        } else {\n            return _buildDomainSeparator();\n        }\n    }\n\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _hashedName, _hashedVersion, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev See {IERC-5267}.\n     */\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        return (\n            hex\"0f\", // 01111\n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n\n    /**\n     * @dev The name parameter for the EIP712 domain.\n     *\n     * NOTE: By default this function reads _name which is an immutable value.\n     * It only reads from storage if necessary (in case the value is too large to fit in a ShortString).\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function _EIP712Name() internal view returns (string memory) {\n        return _name.toStringWithFallback(_nameFallback);\n    }\n\n    /**\n     * @dev The version parameter for the EIP712 domain.\n     *\n     * NOTE: By default this function reads _version which is an immutable value.\n     * It only reads from storage if necessary (in case the value is too large to fit in a ShortString).\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function _EIP712Version() internal view returns (string memory) {\n        return _version.toStringWithFallback(_versionFallback);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MessageHashUtils.sol)\n\npragma solidity ^0.8.20;\n\nimport {Strings} from \"../Strings.sol\";\n\n/**\n * @dev Signature message hash utilities for producing digests to be consumed by {ECDSA} recovery or signing.\n *\n * The library provides methods for generating a hash of a message that conforms to the\n * https://eips.ethereum.org/EIPS/eip-191[EIP 191] and https://eips.ethereum.org/EIPS/eip-712[EIP 712]\n * specifications.\n */\nlibrary MessageHashUtils {\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing a bytes32 `messageHash` with\n     * `\"\\x19Ethereum Signed Message:\\n32\"` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * NOTE: The `messageHash` parameter is intended to be the result of hashing a raw message with\n     * keccak256, although any bytes32 value can be safely used because the final digest will\n     * be re-hashed.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\") // 32 is the bytes-length of messageHash\n            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix\n            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)\n        }\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing an arbitrary `message` with\n     * `\"\\x19Ethereum Signed Message:\\n\" + len(message)` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat(\"\\x19Ethereum Signed Message:\\n\", bytes(Strings.toString(message.length)), message));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x00` (data with intended validator).\n     *\n     * The digest is calculated by prefixing an arbitrary `data` with `\"\\x19\\x00\"` and the intended\n     * `validator` address. Then hashing the result.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex\"19_00\", validator, data));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-712 typed data (EIP-191 version `0x01`).\n     *\n     * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with\n     * `\\x19\\x01` and hashing the result. It corresponds to the hash signed by the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex\"19_01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ShortStrings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ShortStrings.sol)\n\npragma solidity ^0.8.20;\n\nimport {StorageSlot} from \"./StorageSlot.sol\";\n\n// | string  | 0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA   |\n// | length  | 0x                                                              BB |\ntype ShortString is bytes32;\n\n/**\n * @dev This library provides functions to convert short memory strings\n * into a `ShortString` type that can be used as an immutable variable.\n *\n * Strings of arbitrary length can be optimized using this library if\n * they are short enough (up to 31 bytes) by packing them with their\n * length (1 byte) in a single EVM word (32 bytes). Additionally, a\n * fallback mechanism can be used for every other case.\n *\n * Usage example:\n *\n * ```solidity\n * contract Named {\n *     using ShortStrings for *;\n *\n *     ShortString private immutable _name;\n *     string private _nameFallback;\n *\n *     constructor(string memory contractName) {\n *         _name = contractName.toShortStringWithFallback(_nameFallback);\n *     }\n *\n *     function name() external view returns (string memory) {\n *         return _name.toStringWithFallback(_nameFallback);\n *     }\n * }\n * ```\n */\nlibrary ShortStrings {\n    // Used as an identifier for strings longer than 31 bytes.\n    bytes32 private constant FALLBACK_SENTINEL = 0x00000000000000000000000000000000000000000000000000000000000000FF;\n\n    error StringTooLong(string str);\n    error InvalidShortString();\n\n    /**\n     * @dev Encode a string of at most 31 chars into a `ShortString`.\n     *\n     * This will trigger a `StringTooLong` error is the input string is too long.\n     */\n    function toShortString(string memory str) internal pure returns (ShortString) {\n        bytes memory bstr = bytes(str);\n        if (bstr.length > 31) {\n            revert StringTooLong(str);\n        }\n        return ShortString.wrap(bytes32(uint256(bytes32(bstr)) | bstr.length));\n    }\n\n    /**\n     * @dev Decode a `ShortString` back to a \"normal\" string.\n     */\n    function toString(ShortString sstr) internal pure returns (string memory) {\n        uint256 len = byteLength(sstr);\n        // using `new string(len)` would work locally but is not memory safe.\n        string memory str = new string(32);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(str, len)\n            mstore(add(str, 0x20), sstr)\n        }\n        return str;\n    }\n\n    /**\n     * @dev Return the length of a `ShortString`.\n     */\n    function byteLength(ShortString sstr) internal pure returns (uint256) {\n        uint256 result = uint256(ShortString.unwrap(sstr)) & 0xFF;\n        if (result > 31) {\n            revert InvalidShortString();\n        }\n        return result;\n    }\n\n    /**\n     * @dev Encode a string into a `ShortString`, or write it to storage if it is too long.\n     */\n    function toShortStringWithFallback(string memory value, string storage store) internal returns (ShortString) {\n        if (bytes(value).length < 32) {\n            return toShortString(value);\n        } else {\n            StorageSlot.getStringSlot(store).value = value;\n            return ShortString.wrap(FALLBACK_SENTINEL);\n        }\n    }\n\n    /**\n     * @dev Decode a string that was encoded to `ShortString` or written to storage using {setWithFallback}.\n     */\n    function toStringWithFallback(ShortString value, string storage store) internal pure returns (string memory) {\n        if (ShortString.unwrap(value) != FALLBACK_SENTINEL) {\n            return toString(value);\n        } else {\n            return store;\n        }\n    }\n\n    /**\n     * @dev Return the length of a string that was encoded to `ShortString` or written to storage using\n     * {setWithFallback}.\n     *\n     * WARNING: This will return the \"byte length\" of the string. This may not reflect the actual length in terms of\n     * actual characters as the UTF-8 encoding of a single character can span over multiple bytes.\n     */\n    function byteLengthWithFallback(ShortString value, string storage store) internal view returns (uint256) {\n        if (ShortString.unwrap(value) != FALLBACK_SENTINEL) {\n            return byteLength(value);\n        } else {\n            return bytes(store).length;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(newImplementation.code.length > 0);\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"./math/Math.sol\";\nimport {SignedMath} from \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "contracts/BorrowerOperations.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.24;\n\nimport \"./dependencies/CheckContract.sol\";\nimport \"./dependencies/LiquityBase.sol\";\nimport \"./dependencies/SendCollateral.sol\";\nimport \"./interfaces/IBorrowerOperations.sol\";\nimport \"./interfaces/ICollSurplusPool.sol\";\nimport \"./interfaces/IInterestRateManager.sol\";\nimport \"./interfaces/IPCV.sol\";\nimport \"./interfaces/ISortedTroves.sol\";\nimport \"./interfaces/ITroveManager.sol\";\nimport \"./token/IMUSD.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/EIP712.sol\";\n\ncontract BorrowerOperations is\n    LiquityBase,\n    Ownable,\n    CheckContract,\n    SendCollateral,\n    IBorrowerOperations,\n    EIP712\n{\n    using ECDSA for bytes32;\n\n    /* --- Variable container structs  ---\n\n    Used to hold, return and assign variables inside a function, in order to avoid the error:\n    \"CompilerError: Stack too deep\". */\n\n    struct LocalVariables_adjustTrove {\n        uint256 price;\n        uint256 collChange;\n        uint256 netDebtChange;\n        bool isCollIncrease;\n        uint256 debt;\n        uint256 coll;\n        uint256 oldICR;\n        uint256 newICR;\n        uint256 newTCR;\n        uint256 fee;\n        uint256 newColl;\n        uint256 newPrincipal;\n        uint256 newInterest;\n        uint256 stake;\n        uint256 interestOwed;\n        uint256 principalAdjustment;\n        uint256 interestAdjustment;\n        bool isRecoveryMode;\n    }\n\n    struct LocalVariables_openTrove {\n        uint256 price;\n        uint256 fee;\n        uint256 netDebt;\n        uint256 compositeDebt;\n        uint256 ICR;\n        uint256 NICR;\n        uint256 stake;\n        uint256 arrayIndex;\n    }\n\n    struct ContractsCache {\n        ITroveManager troveManager;\n        IActivePool activePool;\n        IMUSD musd;\n        IInterestRateManager interestRateManager;\n    }\n\n    struct OpenTrove {\n        address borrower;\n        uint256 maxFeePercentage;\n        uint256 debtAmount;\n        uint256 assetAmount;\n        address upperHint;\n        address lowerHint;\n        uint256 nonce;\n        uint256 deadline;\n    }\n\n    enum BorrowerOperation {\n        openTrove,\n        closeTrove,\n        adjustTrove\n    }\n\n    string public constant name = \"BorrowerOperations\";\n\n    string private constant SIGNING_DOMAIN = \"BorrowerOperations\";\n    string private constant SIGNATURE_VERSION = \"1\";\n\n    mapping(address => uint256) private _nonces;\n\n    bytes32 private constant OPEN_TROVE_TYPEHASH =\n        keccak256(\n            \"OpenTrove(address borrower,uint256 maxFeePercentage,uint256 debtAmount,uint256 assetAmount,address upperHint,address lowerHint,uint256 nonce,uint256 deadline)\"\n        );\n\n    // refinancing fee is always a percentage of the borrowing (issuance) fee\n    uint8 public refinancingFeePercentage = 20;\n\n    // --- Connected contract declarations ---\n\n    ITroveManager public troveManager;\n\n    address public gasPoolAddress;\n    address public pcvAddress;\n    address public stabilityPoolAddress;\n\n    ICollSurplusPool public collSurplusPool;\n\n    IMUSD public musd;\n    IPCV public pcv;\n    IInterestRateManager public interestRateManager;\n\n    // A doubly linked list of Troves, sorted by their collateral ratios\n    ISortedTroves public sortedTroves;\n\n    modifier onlyGovernance() {\n        require(\n            msg.sender == pcv.council() || msg.sender == pcv.treasury(),\n            \"BorrowerOps: Only governance can call this function\"\n        );\n        _;\n    }\n\n    constructor()\n        Ownable(msg.sender)\n        EIP712(SIGNING_DOMAIN, SIGNATURE_VERSION)\n    {}\n\n    // Calls on PCV behalf\n    function mintBootstrapLoanFromPCV(uint256 _musdToMint) external {\n        require(\n            msg.sender == pcvAddress,\n            \"BorrowerOperations: caller must be PCV\"\n        );\n        musd.mint(pcvAddress, _musdToMint);\n    }\n\n    function burnDebtFromPCV(uint256 _musdToBurn) external {\n        require(\n            msg.sender == pcvAddress,\n            \"BorrowerOperations: caller must be PCV\"\n        );\n        musd.burn(pcvAddress, _musdToBurn);\n    }\n\n    // --- Borrower Trove Operations ---\n    function openTrove(\n        uint256 _maxFeePercentage,\n        uint256 _debtAmount,\n        uint256 _assetAmount,\n        address _upperHint,\n        address _lowerHint\n    ) external payable override {\n        _openTrove(\n            msg.sender,\n            _maxFeePercentage,\n            _debtAmount,\n            _assetAmount,\n            _upperHint,\n            _lowerHint\n        );\n    }\n\n    function openTroveWithSignature(\n        uint256 _maxFeePercentage,\n        uint256 _debtAmount,\n        uint256 _assetAmount,\n        address _upperHint,\n        address _lowerHint,\n        address _borrower,\n        bytes memory _signature,\n        uint256 _deadline\n    ) external payable override {\n        // solhint-disable not-rely-on-time\n        require(block.timestamp <= _deadline, \"Signature expired\");\n        uint256 nonce = _nonces[_borrower];\n        OpenTrove memory openTroveData = OpenTrove({\n            borrower: _borrower,\n            maxFeePercentage: _maxFeePercentage,\n            debtAmount: _debtAmount,\n            assetAmount: _assetAmount,\n            upperHint: _upperHint,\n            lowerHint: _lowerHint,\n            nonce: nonce,\n            deadline: _deadline\n        });\n\n        bytes32 digest = _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    OPEN_TROVE_TYPEHASH,\n                    openTroveData.borrower,\n                    openTroveData.maxFeePercentage,\n                    openTroveData.debtAmount,\n                    openTroveData.assetAmount,\n                    openTroveData.upperHint,\n                    openTroveData.lowerHint,\n                    openTroveData.nonce,\n                    openTroveData.deadline\n                )\n            )\n        );\n\n        address recoveredAddress = ECDSA.recover(digest, _signature);\n        require(recoveredAddress == _borrower, \"Invalid signature\");\n\n        _nonces[_borrower]++;\n\n        _openTrove(\n            _borrower,\n            _maxFeePercentage,\n            _debtAmount,\n            _assetAmount,\n            _upperHint,\n            _lowerHint\n        );\n    }\n\n    // Send collateral to a trove\n    function addColl(\n        uint256 _assetAmount,\n        address _upperHint,\n        address _lowerHint\n    ) external payable override {\n        _assetAmount = msg.value;\n        _adjustTrove(\n            msg.sender,\n            0,\n            0,\n            false,\n            _assetAmount,\n            _upperHint,\n            _lowerHint,\n            0\n        );\n    }\n\n    // Send collateral to a trove. Called by only the Stability Pool.\n    function moveCollateralGainToTrove(\n        address _borrower,\n        uint256 _assetAmount,\n        address _upperHint,\n        address _lowerHint\n    ) external payable override {\n        _requireCallerIsStabilityPool();\n        _assetAmount = msg.value;\n        _adjustTrove(\n            _borrower,\n            0,\n            0,\n            false,\n            _assetAmount,\n            _upperHint,\n            _lowerHint,\n            0\n        );\n    }\n\n    // Withdraw collateral from a trove\n    function withdrawColl(\n        uint256 _amount,\n        address _upperHint,\n        address _lowerHint\n    ) external override {\n        _adjustTrove(\n            msg.sender,\n            _amount,\n            0,\n            false,\n            0,\n            _upperHint,\n            _lowerHint,\n            0\n        );\n    }\n\n    // Withdraw mUSD tokens from a trove: mint new mUSD tokens to the owner, and increase the trove's principal accordingly\n    function withdrawMUSD(\n        uint256 _maxFeePercentage,\n        uint256 _amount,\n        address _upperHint,\n        address _lowerHint\n    ) external override {\n        _adjustTrove(\n            msg.sender,\n            0,\n            _amount,\n            true,\n            0,\n            _upperHint,\n            _lowerHint,\n            _maxFeePercentage\n        );\n    }\n\n    // Repay mUSD tokens to a Trove: Burn the repaid mUSD tokens, and reduce the trove's debt accordingly\n    function repayMUSD(\n        uint256 _amount,\n        address _upperHint,\n        address _lowerHint\n    ) external override {\n        _adjustTrove(\n            msg.sender,\n            0,\n            _amount,\n            false,\n            0,\n            _upperHint,\n            _lowerHint,\n            0\n        );\n    }\n\n    function closeTrove() external override {\n        ITroveManager troveManagerCached = troveManager;\n        IActivePool activePoolCached = activePool;\n        IMUSD musdTokenCached = musd;\n        bool canMint = musdTokenCached.mintList(address(this));\n\n        troveManagerCached.updateSystemAndTroveInterest(msg.sender);\n\n        _requireTroveisActive(troveManagerCached, msg.sender);\n        uint256 price = priceFeed.fetchPrice();\n        if (canMint) {\n            _requireNotInRecoveryMode(price);\n        }\n\n        troveManagerCached.applyPendingRewards(msg.sender);\n\n        uint256 coll = troveManagerCached.getTroveColl(msg.sender);\n        uint256 debt = troveManagerCached.getTroveDebt(msg.sender);\n        uint256 interestOwed = troveManagerCached.getTroveInterestOwed(\n            msg.sender\n        );\n\n        _requireSufficientMUSDBalance(\n            musdTokenCached,\n            msg.sender,\n            debt - MUSD_GAS_COMPENSATION\n        );\n        if (canMint) {\n            uint256 newTCR = _getNewTCRFromTroveChange(\n                coll,\n                false,\n                debt,\n                false,\n                price\n            );\n            _requireNewTCRisAboveCCR(newTCR);\n        }\n\n        troveManagerCached.removeStake(msg.sender);\n        troveManagerCached.closeTrove(msg.sender);\n\n        // slither-disable-next-line reentrancy-events\n        emit TroveUpdated(\n            msg.sender,\n            0,\n            0,\n            0,\n            0,\n            uint8(BorrowerOperation.closeTrove)\n        );\n\n        // Decrease the active pool debt by the principal (subtracting interestOwed from the total debt)\n        activePoolCached.decreaseDebt(\n            debt - MUSD_GAS_COMPENSATION - interestOwed,\n            interestOwed\n        );\n\n        // Burn the repaid mUSD from the user's balance\n        musdTokenCached.burn(msg.sender, debt - MUSD_GAS_COMPENSATION);\n\n        // Burn the gas compensation from the gas pool\n        _repayMUSD(\n            activePoolCached,\n            musdTokenCached,\n            gasPoolAddress,\n            MUSD_GAS_COMPENSATION,\n            0\n        );\n\n        // Send the collateral back to the user\n        activePoolCached.sendCollateral(msg.sender, coll);\n    }\n\n    function refinance(uint256 _maxFeePercentage) external override {\n        ITroveManager troveManagerCached = troveManager;\n        IInterestRateManager interestRateManagerCached = interestRateManager;\n        _requireTroveisActive(troveManagerCached, msg.sender);\n        troveManagerCached.updateSystemAndTroveInterest(msg.sender);\n\n        uint16 oldRate = troveManagerCached.getTroveInterestRate(msg.sender);\n        uint256 oldInterest = troveManagerCached.getTroveInterestOwed(\n            msg.sender\n        );\n        uint256 oldDebt = troveManagerCached.getTroveDebt(msg.sender);\n        uint256 amount = (refinancingFeePercentage * oldDebt) / 100;\n        uint256 fee = _triggerBorrowingFee(\n            troveManagerCached,\n            musd,\n            amount,\n            _maxFeePercentage\n        );\n        // slither-disable-next-line unused-return\n        troveManagerCached.increaseTroveDebt(msg.sender, fee);\n\n        uint256 oldPrincipal = troveManagerCached.getTrovePrincipal(msg.sender);\n\n        interestRateManagerCached.removeInterestFromRate(oldRate, oldInterest);\n        interestRateManagerCached.removePrincipalFromRate(\n            oldRate,\n            oldPrincipal\n        );\n        uint16 newRate = interestRateManagerCached.interestRate();\n        interestRateManagerCached.addInterestToRate(newRate, oldInterest);\n        interestRateManagerCached.addPrincipalToRate(newRate, oldPrincipal);\n\n        troveManagerCached.setTroveInterestRate(\n            msg.sender,\n            interestRateManagerCached.interestRate()\n        );\n\n        uint256 maxBorrowingCapacity = _calculateMaxBorrowingCapacity(\n            troveManagerCached.getTroveColl(msg.sender),\n            priceFeed.fetchPrice()\n        );\n        troveManagerCached.setTroveMaxBorrowingCapacity(\n            msg.sender,\n            maxBorrowingCapacity\n        );\n\n        // slither-disable-next-line reentrancy-events\n        emit RefinancingFeePaid(msg.sender, fee);\n    }\n\n    function adjustTrove(\n        uint256 _maxFeePercentage,\n        uint256 _collWithdrawal,\n        uint256 _debtChange,\n        bool _isDebtIncrease,\n        uint256 _assetAmount,\n        address _upperHint,\n        address _lowerHint\n    ) external payable override {\n        _assetAmount = msg.value;\n        _adjustTrove(\n            msg.sender,\n            _collWithdrawal,\n            _debtChange,\n            _isDebtIncrease,\n            _assetAmount,\n            _upperHint,\n            _lowerHint,\n            _maxFeePercentage\n        );\n    }\n\n    // Claim remaining collateral from a redemption or from a liquidation with ICR > MCR in Recovery Mode\n    function claimCollateral() external override {\n        // send collateral from CollSurplus Pool to owner\n        collSurplusPool.claimColl(msg.sender);\n    }\n\n    function setAddresses(\n        address _activePoolAddress,\n        address _collSurplusPoolAddress,\n        address _defaultPoolAddress,\n        address _gasPoolAddress,\n        address _interestRateManagerAddress,\n        address _musdTokenAddress,\n        address _pcvAddress,\n        address _priceFeedAddress,\n        address _sortedTrovesAddress,\n        address _stabilityPoolAddress,\n        address _troveManagerAddress\n    ) external override onlyOwner {\n        // This makes impossible to open a trove with zero withdrawn mUSD\n        assert(MIN_NET_DEBT > 0);\n\n        checkContract(_activePoolAddress);\n        checkContract(_collSurplusPoolAddress);\n        checkContract(_defaultPoolAddress);\n        checkContract(_gasPoolAddress);\n        checkContract(_interestRateManagerAddress);\n        checkContract(_musdTokenAddress);\n        checkContract(_pcvAddress);\n        checkContract(_priceFeedAddress);\n        checkContract(_sortedTrovesAddress);\n        checkContract(_stabilityPoolAddress);\n        checkContract(_troveManagerAddress);\n\n        // slither-disable-start missing-zero-check\n        activePool = IActivePool(_activePoolAddress);\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        defaultPool = IDefaultPool(_defaultPoolAddress);\n        gasPoolAddress = _gasPoolAddress;\n        interestRateManager = IInterestRateManager(_interestRateManagerAddress);\n        musd = IMUSD(_musdTokenAddress);\n        pcv = IPCV(_pcvAddress);\n        pcvAddress = _pcvAddress;\n        priceFeed = IPriceFeed(_priceFeedAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        stabilityPoolAddress = _stabilityPoolAddress;\n        troveManager = ITroveManager(_troveManagerAddress);\n        // slither-disable-end missing-zero-check\n\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n        emit GasPoolAddressChanged(_gasPoolAddress);\n        emit MUSDTokenAddressChanged(_musdTokenAddress);\n        emit PCVAddressChanged(_pcvAddress);\n        emit PriceFeedAddressChanged(_priceFeedAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n\n        renounceOwnership();\n    }\n\n    function setRefinancingFeePercentage(\n        uint8 _refinanceFeePercentage\n    ) external override onlyGovernance {\n        require(\n            _refinanceFeePercentage <= 100,\n            \"BorrowerOps: Refinancing fee percentage must be <= 100\"\n        );\n        refinancingFeePercentage = _refinanceFeePercentage;\n    }\n\n    function getCompositeDebt(\n        uint256 _debt\n    ) external pure override returns (uint) {\n        return _getCompositeDebt(_debt);\n    }\n\n    function getNonce(address user) public view returns (uint256) {\n        return _nonces[user];\n    }\n\n    function _openTrove(\n        address _borrower,\n        uint256 _maxFeePercentage,\n        uint256 _debtAmount,\n        uint256 _assetAmount,\n        address _upperHint,\n        address _lowerHint\n    ) internal {\n        ContractsCache memory contractsCache = ContractsCache(\n            troveManager,\n            activePool,\n            musd,\n            interestRateManager\n        );\n        // slither-disable-next-line uninitialized-local\n        LocalVariables_openTrove memory vars;\n\n        vars.price = priceFeed.fetchPrice();\n        bool isRecoveryMode = _checkRecoveryMode(vars.price);\n\n        _requireValidMaxFeePercentage(_maxFeePercentage, isRecoveryMode);\n        _requireTroveisNotActive(contractsCache.troveManager, _borrower);\n\n        vars.fee;\n        vars.netDebt = _debtAmount;\n\n        if (!isRecoveryMode) {\n            vars.fee = _triggerBorrowingFee(\n                contractsCache.troveManager,\n                contractsCache.musd,\n                _debtAmount,\n                _maxFeePercentage\n            );\n            vars.netDebt += vars.fee;\n        }\n\n        _requireAtLeastMinNetDebt(vars.netDebt);\n\n        // ICR is based on the composite debt, i.e. the requested amount + borrowing fee + gas comp.\n        vars.compositeDebt = _getCompositeDebt(vars.netDebt);\n        assert(vars.compositeDebt > 0);\n\n        // if BTC overwrite the asset value\n        _assetAmount = msg.value;\n        vars.ICR = LiquityMath._computeCR(\n            _assetAmount,\n            vars.compositeDebt,\n            vars.price\n        );\n        vars.NICR = LiquityMath._computeNominalCR(\n            _assetAmount,\n            vars.compositeDebt\n        );\n\n        if (isRecoveryMode) {\n            _requireICRisAboveCCR(vars.ICR);\n        } else {\n            _requireICRisAboveMCR(vars.ICR);\n            uint256 newTCR = _getNewTCRFromTroveChange(\n                _assetAmount,\n                true,\n                vars.compositeDebt,\n                true,\n                vars.price\n            ); // bools: coll increase, debt increase\n            _requireNewTCRisAboveCCR(newTCR);\n        }\n\n        contractsCache.troveManager.setTroveInterestRate(\n            _borrower,\n            contractsCache.interestRateManager.interestRate()\n        );\n\n        // Set the trove struct's properties\n        contractsCache.troveManager.setTroveStatus(\n            _borrower,\n            ITroveManager.Status.active\n        );\n        // slither-disable-next-line unused-return\n        contractsCache.troveManager.increaseTroveColl(_borrower, _assetAmount);\n        // slither-disable-next-line unused-return\n        contractsCache.troveManager.increaseTroveDebt(\n            _borrower,\n            vars.compositeDebt\n        );\n\n        // solhint-disable not-rely-on-time\n        contractsCache.troveManager.setTroveLastInterestUpdateTime(\n            _borrower,\n            block.timestamp\n        );\n        // solhint-enable not-rely-on-time\n\n        // Set trove's max borrowing capacity to the amount that would put it at 110% ICR\n        uint256 maxBorrowingCapacity = _calculateMaxBorrowingCapacity(\n            _assetAmount,\n            vars.price\n        );\n        contractsCache.troveManager.setTroveMaxBorrowingCapacity(\n            _borrower,\n            maxBorrowingCapacity\n        );\n\n        contractsCache.troveManager.updateTroveRewardSnapshots(_borrower);\n        vars.stake = contractsCache.troveManager.updateStakeAndTotalStakes(\n            _borrower\n        );\n\n        sortedTroves.insert(_borrower, vars.NICR, _upperHint, _lowerHint);\n        vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(\n            _borrower\n        );\n\n        /*\n         * Move the collateral to the Active Pool, and mint the amount to the borrower\n         * If the user has insuffient tokens to do the transfer to the Active Pool an error will cause the transaction to revert.\n         */\n        _activePoolAddColl(contractsCache.activePool, _assetAmount);\n        _withdrawMUSD(\n            contractsCache.activePool,\n            contractsCache.musd,\n            _borrower,\n            _debtAmount,\n            vars.netDebt\n        );\n        // Move the mUSD gas compensation to the Gas Pool\n        _withdrawMUSD(\n            contractsCache.activePool,\n            contractsCache.musd,\n            gasPoolAddress,\n            MUSD_GAS_COMPENSATION,\n            MUSD_GAS_COMPENSATION\n        );\n\n        // slither-disable-start reentrancy-events\n        emit TroveCreated(_borrower, vars.arrayIndex);\n\n        emit TroveUpdated(\n            _borrower,\n            vars.compositeDebt,\n            0,\n            _assetAmount,\n            vars.stake,\n            uint8(BorrowerOperation.openTrove)\n        );\n        emit BorrowingFeePaid(_borrower, vars.fee);\n        // slither-disable-end reentrancy-events\n    }\n    /*\n     * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.\n     *\n     * It therefore expects either a positive msg.value, or a positive _collWithdrawal argument.\n     *\n     * If both are positive, it will revert.\n     */\n    function _adjustTrove(\n        address _borrower,\n        uint256 _collWithdrawal,\n        uint256 _mUSDChange,\n        bool _isDebtIncrease,\n        uint256 _assetAmount,\n        address _upperHint,\n        address _lowerHint,\n        uint256 _maxFeePercentage\n    ) internal {\n        ContractsCache memory contractsCache = ContractsCache(\n            troveManager,\n            activePool,\n            musd,\n            interestRateManager\n        );\n\n        contractsCache.troveManager.updateSystemAndTroveInterest(_borrower);\n\n        // slither-disable-next-line uninitialized-local\n        LocalVariables_adjustTrove memory vars;\n\n        // Snapshot interest and principal before repayment so we can correctly adjust the active pool\n        vars.interestOwed = contractsCache.troveManager.getTroveInterestOwed(\n            _borrower\n        );\n\n        (vars.principalAdjustment, vars.interestAdjustment) = contractsCache\n            .interestRateManager\n            .calculateDebtAdjustment(vars.interestOwed, _mUSDChange);\n\n        vars.price = priceFeed.fetchPrice();\n        vars.isRecoveryMode = _checkRecoveryMode(vars.price);\n\n        if (_isDebtIncrease) {\n            _requireValidMaxFeePercentage(\n                _maxFeePercentage,\n                vars.isRecoveryMode\n            );\n            _requireNonZeroDebtChange(_mUSDChange);\n        }\n        _requireSingularCollChange(_collWithdrawal, _assetAmount);\n        _requireNonZeroAdjustment(_collWithdrawal, _mUSDChange, _assetAmount);\n        _requireTroveisActive(contractsCache.troveManager, _borrower);\n\n        // Confirm the operation is either a borrower adjusting their own trove, or a pure collateral transfer from the Stability Pool to a trove\n        assert(\n            msg.sender == _borrower ||\n                (msg.sender == stabilityPoolAddress &&\n                    _assetAmount > 0 &&\n                    _mUSDChange == 0)\n        );\n\n        contractsCache.troveManager.applyPendingRewards(_borrower);\n\n        // Get the collChange based on whether or not collateral was sent in the transaction\n        (vars.collChange, vars.isCollIncrease) = _getCollChange(\n            _assetAmount,\n            _collWithdrawal\n        );\n\n        vars.netDebtChange = _mUSDChange;\n\n        // If the adjustment incorporates a principal increase and system is in Normal Mode, then trigger a borrowing fee\n        if (_isDebtIncrease && !vars.isRecoveryMode) {\n            vars.fee = _triggerBorrowingFee(\n                contractsCache.troveManager,\n                contractsCache.musd,\n                _mUSDChange,\n                _maxFeePercentage\n            );\n            vars.netDebtChange += vars.fee; // The raw debt change includes the fee\n        }\n\n        vars.debt = contractsCache.troveManager.getTroveDebt(_borrower);\n        vars.coll = contractsCache.troveManager.getTroveColl(_borrower);\n\n        // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment\n        vars.oldICR = LiquityMath._computeCR(vars.coll, vars.debt, vars.price);\n        vars.newICR = _getNewICRFromTroveChange(\n            vars.coll,\n            vars.debt,\n            vars.collChange,\n            vars.isCollIncrease,\n            vars.netDebtChange,\n            _isDebtIncrease,\n            vars.price\n        );\n        assert(_collWithdrawal <= vars.coll);\n\n        // Check the adjustment satisfies all conditions for the current system mode\n        _requireValidAdjustmentInCurrentMode(\n            vars.isRecoveryMode,\n            _collWithdrawal,\n            _isDebtIncrease,\n            vars\n        );\n\n        // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough mUSD\n        if (!_isDebtIncrease && _mUSDChange > 0) {\n            _requireAtLeastMinNetDebt(\n                _getNetDebt(vars.debt) - vars.netDebtChange\n            );\n            _requireValidMUSDRepayment(vars.debt, vars.netDebtChange);\n            _requireSufficientMUSDBalance(\n                contractsCache.musd,\n                _borrower,\n                vars.netDebtChange\n            );\n        }\n\n        (\n            vars.newColl,\n            vars.newPrincipal,\n            vars.newInterest\n        ) = _updateTroveFromAdjustment(\n            contractsCache.troveManager,\n            _borrower,\n            vars.collChange,\n            vars.isCollIncrease,\n            vars.netDebtChange,\n            _isDebtIncrease\n        );\n        vars.stake = contractsCache.troveManager.updateStakeAndTotalStakes(\n            _borrower\n        );\n\n        // Re-insert trove in to the sorted list\n        uint256 newNICR = _getNewNominalICRFromTroveChange(\n            vars.coll,\n            vars.debt,\n            vars.collChange,\n            vars.isCollIncrease,\n            vars.netDebtChange,\n            _isDebtIncrease\n        );\n        sortedTroves.reInsert(_borrower, newNICR, _upperHint, _lowerHint);\n\n        // slither-disable-next-line reentrancy-events\n        emit TroveUpdated(\n            _borrower,\n            vars.newPrincipal,\n            vars.newInterest,\n            vars.newColl,\n            vars.stake,\n            uint8(BorrowerOperation.adjustTrove)\n        );\n        // slither-disable-next-line reentrancy-events\n        emit BorrowingFeePaid(msg.sender, vars.fee);\n\n        // Use the unmodified _mUSDChange here, as we don't send the fee to the user\n        _moveTokensAndCollateralfromAdjustment(\n            contractsCache.activePool,\n            contractsCache.musd,\n            msg.sender,\n            vars.collChange,\n            vars.isCollIncrease,\n            _isDebtIncrease ? _mUSDChange : vars.principalAdjustment,\n            vars.interestAdjustment,\n            _isDebtIncrease,\n            vars.netDebtChange\n        );\n    }\n\n    // Issue the specified amount of mUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a MUSDFee)\n    function _withdrawMUSD(\n        IActivePool _activePool,\n        IMUSD _musd,\n        address _account,\n        uint256 _debtAmount,\n        uint256 _netDebtIncrease\n    ) internal {\n        _activePool.increaseDebt(_netDebtIncrease, 0);\n        _musd.mint(_account, _debtAmount);\n    }\n\n    // Burn the specified amount of MUSD from _account and decreases the total active debt\n    function _repayMUSD(\n        IActivePool _activePool,\n        IMUSD _musd,\n        address _account,\n        uint256 _principal,\n        uint256 _interest\n    ) internal {\n        _activePool.decreaseDebt(_principal, _interest);\n        _musd.burn(_account, _principal + _interest);\n    }\n\n    function _moveTokensAndCollateralfromAdjustment(\n        IActivePool _activePool,\n        IMUSD _musd,\n        address _borrower,\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _principalChange,\n        uint256 _interestChange,\n        bool _isDebtIncrease,\n        uint256 _netDebtChange\n    ) internal {\n        if (_isDebtIncrease) {\n            _withdrawMUSD(\n                _activePool,\n                _musd,\n                _borrower,\n                _principalChange,\n                _netDebtChange\n            );\n        } else {\n            _repayMUSD(\n                _activePool,\n                _musd,\n                _borrower,\n                _principalChange,\n                _interestChange\n            );\n        }\n\n        if (_isCollIncrease) {\n            _activePoolAddColl(_activePool, _collChange);\n        } else {\n            _activePool.sendCollateral(_borrower, _collChange);\n        }\n    }\n\n    // Send collateral to Active Pool and increase its recorded collateral balance\n    function _activePoolAddColl(\n        IActivePool _activePool,\n        uint256 _amount\n    ) internal {\n        _sendCollateral(address(_activePool), _amount);\n    }\n\n    // Update trove's coll and debt based on whether they increase or decrease\n    function _updateTroveFromAdjustment(\n        ITroveManager _troveManager,\n        address _borrower,\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _debtChange,\n        bool _isDebtIncrease\n    )\n        internal\n        returns (uint256 newColl, uint256 newPrincipal, uint256 newInterest)\n    {\n        newColl = (_isCollIncrease)\n            ? _troveManager.increaseTroveColl(_borrower, _collChange)\n            : _troveManager.decreaseTroveColl(_borrower, _collChange);\n\n        if (_isDebtIncrease) {\n            newPrincipal = _troveManager.increaseTroveDebt(\n                _borrower,\n                _debtChange\n            );\n        } else {\n            (newPrincipal, newInterest) = _troveManager.decreaseTroveDebt(\n                _borrower,\n                _debtChange\n            );\n        }\n    }\n\n    // --- Helper functions ---\n\n    function _triggerBorrowingFee(\n        ITroveManager _troveManager,\n        IMUSD _musd,\n        uint256 _amount,\n        uint256 _maxFeePercentage\n    ) internal returns (uint) {\n        _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable\n        uint256 fee = _troveManager.getBorrowingFee(_amount);\n\n        _requireUserAcceptsFee(fee, _amount, _maxFeePercentage);\n\n        // Send fee to PCV contract\n        _musd.mint(pcvAddress, fee);\n        return fee;\n    }\n\n    function _requireNotInRecoveryMode(uint256 _price) internal view {\n        require(\n            !_checkRecoveryMode(_price),\n            \"BorrowerOps: Operation not permitted during Recovery Mode\"\n        );\n    }\n\n    function _requireTroveisNotActive(\n        ITroveManager _troveManager,\n        address _borrower\n    ) internal view {\n        ITroveManager.Status status = _troveManager.getTroveStatus(_borrower);\n        require(\n            status != ITroveManager.Status.active,\n            \"BorrowerOps: Trove is active\"\n        );\n    }\n\n    function _getNewTCRFromTroveChange(\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _debtChange,\n        bool _isDebtIncrease,\n        uint256 _price\n    ) internal view returns (uint) {\n        uint256 totalColl = getEntireSystemColl();\n        uint256 totalDebt = getEntireSystemDebt();\n\n        totalColl = _isCollIncrease\n            ? totalColl + _collChange\n            : totalColl - _collChange;\n        totalDebt = _isDebtIncrease\n            ? totalDebt + _debtChange\n            : totalDebt - _debtChange;\n\n        uint256 newTCR = LiquityMath._computeCR(totalColl, totalDebt, _price);\n        return newTCR;\n    }\n\n    function _requireCallerIsStabilityPool() internal view {\n        require(\n            msg.sender == stabilityPoolAddress,\n            \"BorrowerOps: Caller is not Stability Pool\"\n        );\n    }\n\n    function _requireTroveisActive(\n        ITroveManager _troveManager,\n        address _borrower\n    ) internal view {\n        ITroveManager.Status status = _troveManager.getTroveStatus(_borrower);\n\n        require(\n            status == ITroveManager.Status.active,\n            \"BorrowerOps: Trove does not exist or is closed\"\n        );\n    }\n\n    /*\n     * In Normal Mode, ensure:\n     *\n     * - The new ICR is above MCR\n     * - The adjustment won't pull the TCR below CCR\n     */\n    function _requireValidAdjustmentInNormalMode(\n        bool _isDebtIncrease,\n        LocalVariables_adjustTrove memory _vars\n    ) internal view {\n        _requireICRisAboveMCR(_vars.newICR);\n        _vars.newTCR = _getNewTCRFromTroveChange(\n            _vars.collChange,\n            _vars.isCollIncrease,\n            _vars.netDebtChange,\n            _isDebtIncrease,\n            _vars.price\n        );\n        _requireNewTCRisAboveCCR(_vars.newTCR);\n    }\n\n    function _requireValidAdjustmentInCurrentMode(\n        bool _isRecoveryMode,\n        uint256 _collWithdrawal,\n        bool _isDebtIncrease,\n        LocalVariables_adjustTrove memory _vars\n    ) internal view {\n        if (_isRecoveryMode) {\n            _requireValidAdjustmentInRecoveryMode(\n                _collWithdrawal,\n                _isDebtIncrease,\n                _vars\n            );\n        } else {\n            _requireValidAdjustmentInNormalMode(_isDebtIncrease, _vars);\n        }\n    }\n\n    function _requireSufficientMUSDBalance(\n        IMUSD _musd,\n        address _borrower,\n        uint256 _debtRepayment\n    ) internal view {\n        require(\n            _musd.balanceOf(_borrower) >= _debtRepayment,\n            \"BorrowerOps: Caller doesnt have enough mUSD to make repayment\"\n        );\n    }\n\n    /*\n     * In Recovery Mode, only allow:\n     *\n     * - Pure collateral top-up\n     * - Pure debt repayment\n     * - Collateral top-up with debt repayment\n     * - A debt increase combined with a collateral top-up which makes the ICR\n     * >= 150% and improves the ICR (and by extension improves the TCR).\n     */\n    function _requireValidAdjustmentInRecoveryMode(\n        uint256 _collWithdrawal,\n        bool _isDebtIncrease,\n        LocalVariables_adjustTrove memory _vars\n    ) internal pure {\n        _requireNoCollWithdrawal(_collWithdrawal);\n        if (_isDebtIncrease) {\n            _requireICRisAboveCCR(_vars.newICR);\n            _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);\n        }\n    }\n\n    function _getCollChange(\n        uint256 _collReceived,\n        uint256 _requestedCollWithdrawal\n    ) internal pure returns (uint256 collChange, bool isCollIncrease) {\n        if (_collReceived != 0) {\n            collChange = _collReceived;\n            isCollIncrease = true;\n        } else {\n            collChange = _requestedCollWithdrawal;\n        }\n    }\n\n    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.\n    function _getNewICRFromTroveChange(\n        uint256 _coll,\n        uint256 _debt,\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _debtChange,\n        bool _isDebtIncrease,\n        uint256 _price\n    ) internal pure returns (uint) {\n        (uint256 newColl, uint256 newDebt) = _getNewTroveAmounts(\n            _coll,\n            _debt,\n            _collChange,\n            _isCollIncrease,\n            _debtChange,\n            _isDebtIncrease\n        );\n        uint256 newICR = LiquityMath._computeCR(newColl, newDebt, _price);\n        return newICR;\n    }\n\n    function _getNewTroveAmounts(\n        uint256 _coll,\n        uint256 _debt,\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _debtChange,\n        bool _isDebtIncrease\n    ) internal pure returns (uint newColl, uint newDebt) {\n        newColl = _isCollIncrease ? _coll + _collChange : _coll - _collChange;\n        newDebt = _isDebtIncrease ? _debt + _debtChange : _debt - _debtChange;\n    }\n\n    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.\n    function _getNewNominalICRFromTroveChange(\n        uint256 _coll,\n        uint256 _debt,\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _debtChange,\n        bool _isDebtIncrease\n    ) internal pure returns (uint) {\n        (uint256 newColl, uint256 newDebt) = _getNewTroveAmounts(\n            _coll,\n            _debt,\n            _collChange,\n            _isCollIncrease,\n            _debtChange,\n            _isDebtIncrease\n        );\n\n        return LiquityMath._computeNominalCR(newColl, newDebt);\n    }\n\n    function _calculateMaxBorrowingCapacity(\n        uint256 _coll,\n        uint256 _price\n    ) internal pure returns (uint) {\n        return (_coll * _price) / (110 * 1e16);\n    }\n\n    function _requireValidMaxFeePercentage(\n        uint256 _maxFeePercentage,\n        bool _isRecoveryMode\n    ) internal pure {\n        if (_isRecoveryMode) {\n            require(\n                _maxFeePercentage <= DECIMAL_PRECISION,\n                \"Max fee percentage must be less than or equal to 100%\"\n            );\n        } else {\n            require(\n                _maxFeePercentage >= BORROWING_FEE_FLOOR &&\n                    _maxFeePercentage <= DECIMAL_PRECISION,\n                \"Max fee percentage must be between 0.5% and 100%\"\n            );\n        }\n    }\n\n    function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {\n        require(\n            _netDebt >= MIN_NET_DEBT,\n            \"BorrowerOps: Trove's net debt must be greater than minimum\"\n        );\n    }\n\n    function _requireICRisAboveMCR(uint256 _newICR) internal pure {\n        require(\n            _newICR >= MCR,\n            \"BorrowerOps: An operation that would result in ICR < MCR is not permitted\"\n        );\n    }\n\n    function _requireICRisAboveCCR(uint256 _newICR) internal pure {\n        require(\n            _newICR >= CCR,\n            \"BorrowerOps: Operation must leave trove with ICR >= CCR\"\n        );\n    }\n\n    function _requireNewTCRisAboveCCR(uint256 _newTCR) internal pure {\n        require(\n            _newTCR >= CCR,\n            \"BorrowerOps: An operation that would result in TCR < CCR is not permitted\"\n        );\n    }\n\n    function _requireNonZeroDebtChange(uint256 _debtChange) internal pure {\n        require(\n            _debtChange > 0,\n            \"BorrowerOps: Debt increase requires non-zero debtChange\"\n        );\n    }\n\n    function _requireSingularCollChange(\n        uint256 _collWithdrawal,\n        uint256 _assetAmount\n    ) internal pure {\n        require(\n            _assetAmount == 0 || _collWithdrawal == 0,\n            \"BorrowerOperations: Cannot withdraw and add coll\"\n        );\n    }\n\n    function _requireNonZeroAdjustment(\n        uint256 _collWithdrawal,\n        uint256 _debtChange,\n        uint256 _assetAmount\n    ) internal pure {\n        require(\n            _assetAmount != 0 || _collWithdrawal != 0 || _debtChange != 0,\n            \"BorrowerOps: There must be either a collateral change or a debt change\"\n        );\n    }\n\n    function _requireNoCollWithdrawal(uint256 _collWithdrawal) internal pure {\n        require(\n            _collWithdrawal == 0,\n            \"BorrowerOps: Collateral withdrawal not permitted Recovery Mode\"\n        );\n    }\n\n    function _requireNewICRisAboveOldICR(\n        uint256 _newICR,\n        uint256 _oldICR\n    ) internal pure {\n        require(\n            _newICR >= _oldICR,\n            \"BorrowerOps: Cannot decrease your Trove's ICR in Recovery Mode\"\n        );\n    }\n\n    function _requireValidMUSDRepayment(\n        uint256 _currentDebt,\n        uint256 _debtRepayment\n    ) internal pure {\n        require(\n            _debtRepayment <= _currentDebt - MUSD_GAS_COMPENSATION,\n            \"BorrowerOps: Amount repaid must not be larger than the Trove's debt\"\n        );\n    }\n}\n"
    },
    "contracts/dependencies/BaseMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\ncontract BaseMath {\n    uint256 public constant DECIMAL_PRECISION = 1e18;\n}\n"
    },
    "contracts/dependencies/CheckContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.24;\n\ncontract CheckContract {\n    /**\n     * Check that the account is an already deployed non-destroyed contract.\n     * See: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol#L12\n     */\n    function checkContract(address _account) internal view {\n        require(_account != address(0), \"Account cannot be zero address\");\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            size := extcodesize(_account)\n        }\n        require(size > 0, \"Account code size cannot be zero\");\n    }\n}\n"
    },
    "contracts/dependencies/LiquityBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.24;\n\nimport \"./BaseMath.sol\";\nimport \"./LiquityMath.sol\";\nimport \"../interfaces/IActivePool.sol\";\nimport \"../interfaces/IDefaultPool.sol\";\nimport \"../interfaces/IPriceFeed.sol\";\nimport \"../interfaces/ILiquityBase.sol\";\n\n/*\n * Base contract for TroveManager, BorrowerOperations and StabilityPool. Contains global system constants and\n * common functions.\n */\nabstract contract LiquityBase is BaseMath, ILiquityBase {\n    uint256 public constant _100pct = 1e18; // 1e18 == 100%\n\n    // Minimum collateral ratio for individual troves\n    uint256 public constant MCR = 1.1e18; // 110%\n\n    // Critical system collateral ratio. If the system's total collateral ratio (TCR) falls below the CCR, Recovery Mode is triggered.\n    uint256 public constant CCR = 1.5e18; // 150%\n\n    // Amount of mUSD to be locked in gas pool on opening troves\n    uint256 public constant MUSD_GAS_COMPENSATION = 200e18;\n\n    // Minimum amount of net mUSD debt a trove must have\n    uint256 public constant MIN_NET_DEBT = 1800e18;\n    // uint256 constant public MIN_NET_DEBT = 0;\n\n    uint256 public constant PERCENT_DIVISOR = 200; // dividing by 200 yields 0.5%\n\n    uint256 public constant BORROWING_FEE_FLOOR = ((DECIMAL_PRECISION * 5) /\n        1000); // 0.5%\n\n    // slither-disable-next-line all\n    IActivePool public activePool;\n\n    // slither-disable-next-line all\n    IDefaultPool public defaultPool;\n\n    // slither-disable-next-line all\n    IPriceFeed public override priceFeed;\n\n    // --- Gas compensation functions ---\n\n    function getEntireSystemColl()\n        public\n        view\n        returns (uint256 entireSystemColl)\n    {\n        uint256 activeColl = activePool.getCollateralBalance();\n        uint256 liquidatedColl = defaultPool.getCollateralBalance();\n\n        return activeColl + liquidatedColl;\n    }\n\n    function getEntireSystemDebt()\n        public\n        view\n        returns (uint256 entireSystemDebt)\n    {\n        uint256 activeDebt = activePool.getDebt();\n        uint256 closedDebt = defaultPool.getDebt();\n\n        return activeDebt + closedDebt;\n    }\n\n    function _getTCR(uint256 _price) internal view returns (uint256 TCR) {\n        uint256 entireSystemColl = getEntireSystemColl();\n        uint256 entireSystemDebt = getEntireSystemDebt();\n\n        TCR = LiquityMath._computeCR(\n            entireSystemColl,\n            entireSystemDebt,\n            _price\n        );\n        return TCR;\n    }\n\n    function _checkRecoveryMode(uint256 _price) internal view returns (bool) {\n        uint256 TCR = _getTCR(_price);\n        return TCR < CCR;\n    }\n\n    function _requireUserAcceptsFee(\n        uint256 _fee,\n        uint256 _amount,\n        uint256 _maxFeePercentage\n    ) internal pure {\n        uint256 feePercentage = (_fee * DECIMAL_PRECISION) / _amount;\n        require(\n            feePercentage <= _maxFeePercentage,\n            \"Fee exceeded provided maximum\"\n        );\n    }\n\n    // Returns the composite debt (drawn debt + gas compensation) of a trove, for the purpose of ICR calculation\n    function _getCompositeDebt(uint256 _debt) internal pure returns (uint) {\n        return _debt + MUSD_GAS_COMPENSATION;\n    }\n\n    function _getNetDebt(uint256 _debt) internal pure returns (uint) {\n        return _debt - MUSD_GAS_COMPENSATION;\n    }\n\n    // Return the amount of collateral to be drawn from a trove's collateral and sent as gas compensation.\n    function _getCollGasCompensation(\n        uint256 _entireColl\n    ) internal pure returns (uint) {\n        return _entireColl / PERCENT_DIVISOR;\n    }\n}\n"
    },
    "contracts/dependencies/LiquityMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.24;\n\nlibrary LiquityMath {\n    uint256 internal constant DECIMAL_PRECISION = 1e18;\n\n    /* Precision for Nominal ICR (independent of price). Rationale for the value:\n     *\n     * - Making it “too high” could lead to overflows.\n     * - Making it “too low” could lead to an ICR equal to zero, due to truncation from Solidity floor division.\n     *\n     * This value of 1e20 is chosen for safety: the NICR will only overflow for numerator > ~1e39 BTC,\n     * and will only truncate to 0 if the denominator is at least 1e20 times greater than the numerator.\n     *\n     */\n    uint256 internal constant NICR_PRECISION = 1e20;\n\n    function _min(uint256 _a, uint256 _b) internal pure returns (uint) {\n        return (_a < _b) ? _a : _b;\n    }\n\n    /*\n     * Multiply two decimal numbers and use normal rounding rules:\n     * -round product up if 19'th mantissa digit >= 5\n     * -round product down if 19'th mantissa digit < 5\n     *\n     * Used only inside the exponentiation, _decPow().\n     */\n    function decMul(\n        uint256 x,\n        uint256 y\n    ) internal pure returns (uint256 decProd) {\n        uint256 prod_xy = x * y;\n\n        decProd = (prod_xy + (DECIMAL_PRECISION / 2)) / DECIMAL_PRECISION;\n    }\n\n    /*\n     * _decPow: Exponentiation function for 18-digit decimal base, and integer exponent n.\n     *\n     * Uses the efficient \"exponentiation by squaring\" algorithm. O(log(n)) complexity.\n     *\n     * Called by one function that represent time in units of minutes:\n     * 1) TroveManager._calcDecayedBaseRate\n     *\n     * The exponent is capped to avoid reverting due to overflow. The cap 525600000 equals\n     * \"minutes in 1000 years\": 60 * 24 * 365 * 1000\n     *\n     * If a period of > 1000 years is ever used as an exponent in either of the above functions, the result will be\n     * negligibly different from just passing the cap, since:\n     *\n     * In function 1), the decayed base rate will be 0 for 1000 years or > 1000 years\n     * In function 2), the difference in tokens issued at 1000 years and any time > 1000 years, will be negligible\n     */\n    function _decPow(\n        uint256 _base,\n        uint256 _minutes\n    ) internal pure returns (uint) {\n        if (_minutes > 5.256e8) {\n            _minutes = 5.256e8;\n        } // cap to avoid overflow\n\n        if (_minutes == 0) {\n            return DECIMAL_PRECISION;\n        }\n\n        uint256 y = DECIMAL_PRECISION;\n        uint256 x = _base;\n        uint256 n = _minutes;\n\n        // Exponentiation-by-squaring\n        while (n > 1) {\n            if (n % 2 == 0) {\n                x = decMul(x, x);\n                n = n / 2;\n            } else {\n                // if (n % 2 != 0)\n                y = decMul(x, y);\n                x = decMul(x, x);\n                n = (n - 1) / 2;\n            }\n        }\n\n        return decMul(x, y);\n    }\n\n    function _getAbsoluteDifference(\n        uint256 _a,\n        uint256 _b\n    ) internal pure returns (uint) {\n        return (_a >= _b) ? _a - _b : _b - _a;\n    }\n\n    function _computeNominalCR(\n        uint256 _coll,\n        uint256 _debt\n    ) internal pure returns (uint) {\n        if (_debt > 0) {\n            return (_coll * NICR_PRECISION) / _debt;\n        }\n        // Return the maximal value for uint256 if the Trove has a debt of 0. Represents \"infinite\" CR.\n        else {\n            // if (_debt == 0)\n            return type(uint256).max;\n        }\n    }\n\n    function _computeCR(\n        uint256 _coll,\n        uint256 _debt,\n        uint256 _price\n    ) internal pure returns (uint) {\n        if (_debt > 0) {\n            uint256 newCollRatio = (_coll * _price) / _debt;\n\n            return newCollRatio;\n        }\n        // Return the maximal value for uint256 if the Trove has a debt of 0. Represents \"infinite\" CR.\n        else {\n            // if (_debt == 0)\n            return type(uint256).max;\n        }\n    }\n}\n"
    },
    "contracts/dependencies/SendCollateral.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.24;\n\ncontract SendCollateral {\n    /**\n     * Sends collateral to recipient\n     */\n    function _sendCollateral(address _recipient, uint256 _amount) internal {\n        // slither-disable-next-line low-level-calls\n        (bool success, ) = _recipient.call{value: _amount}(\"\"); // re-entry is fine here\n        require(success, \"Sending BTC failed\");\n    }\n}\n"
    },
    "contracts/interfaces/IActivePool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.24;\n\nimport \"./IPool.sol\";\n\ninterface IActivePool is IPool {\n    // --- Events ---\n    event BorrowerOperationsAddressChanged(\n        address _newBorrowerOperationsAddress\n    );\n    event CollSurplusPoolAddressChanged(address _newCollSurplusPoolAddress);\n    event InterestRateManagerAddressChanged(\n        address _interestRateManagerAddress\n    );\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n\n    event ActivePoolDebtUpdated(uint256 _principal, uint256 _interest);\n    event ActivePoolCollateralBalanceUpdated(uint256 _collateral);\n\n    // --- Functions ---\n    function sendCollateral(address _account, uint256 _amount) external;\n}\n"
    },
    "contracts/interfaces/IBorrowerOperations.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.24;\n\n// Common interface for the Trove Manager.\ninterface IBorrowerOperations {\n    // --- Events ---\n\n    event ActivePoolAddressChanged(address _activePoolAddress);\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\n    event GasPoolAddressChanged(address _gasPoolAddress);\n    event MUSDTokenAddressChanged(address _musdTokenAddress);\n    event PCVAddressChanged(address _pcvAddress);\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n\n    event TroveCreated(address indexed _borrower, uint256 arrayIndex);\n    event TroveUpdated(\n        address indexed _borrower,\n        uint256 _principal,\n        uint256 _interest,\n        uint256 _coll,\n        uint256 stake,\n        uint8 operation\n    );\n    event BorrowingFeePaid(address indexed _borrower, uint256 _fee);\n    event RefinancingFeePaid(address indexed _borrower, uint256 _fee);\n\n    // --- Functions ---\n\n    function setAddresses(\n        address _activePoolAddress,\n        address _collSurplusPoolAddress,\n        address _defaultPoolAddress,\n        address _gasPoolAddress,\n        address _interestRateManagerAddress,\n        address _musdTokenAddress,\n        address _pcvAddress,\n        address _priceFeedAddress,\n        address _sortedTrovesAddress,\n        address _stabilityPoolAddress,\n        address _troveManagerAddress\n    ) external;\n\n    function setRefinancingFeePercentage(\n        uint8 _refinanceFeePercentage\n    ) external;\n\n    function openTrove(\n        uint256 _maxFeePercentage,\n        uint256 _debtAmount,\n        uint256 _assetAmount,\n        address _upperHint,\n        address _lowerHint\n    ) external payable;\n\n    function openTroveWithSignature(\n        uint256 _maxFeePercentage,\n        uint256 _debtAmount,\n        uint256 _assetAmount,\n        address _upperHint,\n        address _lowerHint,\n        address _borrower,\n        bytes memory _signature,\n        uint256 _deadline\n    ) external payable;\n\n    function addColl(\n        uint256 _assetAmount,\n        address _upperHint,\n        address _lowerHint\n    ) external payable;\n\n    function moveCollateralGainToTrove(\n        address _borrower,\n        uint256 _assetAmount,\n        address _upperHint,\n        address _lowerHint\n    ) external payable;\n\n    function withdrawColl(\n        uint256 _amount,\n        address _upperHint,\n        address _lowerHint\n    ) external;\n\n    function withdrawMUSD(\n        uint256 _maxFeePercentage,\n        uint256 _amount,\n        address _upperHint,\n        address _lowerHint\n    ) external;\n\n    function repayMUSD(\n        uint256 _amount,\n        address _upperHint,\n        address _lowerHint\n    ) external;\n\n    function closeTrove() external;\n\n    function refinance(uint256 _maxFeePercentage) external;\n\n    function adjustTrove(\n        uint256 _maxFeePercentage,\n        uint256 _collWithdrawal,\n        uint256 _debtChange,\n        bool _isDebtIncrease,\n        uint256 _assetAmount,\n        address _upperHint,\n        address _lowerHint\n    ) external payable;\n\n    function claimCollateral() external;\n\n    function getCompositeDebt(uint256 _debt) external pure returns (uint);\n}\n"
    },
    "contracts/interfaces/ICollSurplusPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.24;\n\ninterface ICollSurplusPool {\n    // --- Events ---\n\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\n    event BorrowerOperationsAddressChanged(\n        address _newBorrowerOperationsAddress\n    );\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n\n    event CollBalanceUpdated(address indexed _account, uint256 _newBalance);\n    event CollateralSent(address _to, uint256 _amount);\n\n    // --- Contract setters ---\n\n    function setAddresses(\n        address _activePoolAddress,\n        address _borrowerOperationsAddress,\n        address _troveManagerAddress\n    ) external;\n\n    function accountSurplus(address _account, uint256 _amount) external;\n\n    function claimColl(address _account) external;\n\n    function getCollateralBalance() external view returns (uint);\n\n    function getCollateral(address _account) external view returns (uint);\n}\n"
    },
    "contracts/interfaces/IDefaultPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.24;\n\nimport \"./IPool.sol\";\n\ninterface IDefaultPool is IPool {\n    // --- Events ---\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event DefaultPoolDebtUpdated(uint256 _principal, uint256 _interest);\n    event DefaultPoolCollateralBalanceUpdated(uint256 _collateral);\n\n    // --- Functions ---\n    function sendCollateralToActivePool(uint256 _amount) external;\n\n    function getLastInterestUpdatedTime() external view returns (uint);\n}\n"
    },
    "contracts/interfaces/IInterestRateManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.24;\n\ninterface IInterestRateManager {\n    struct InterestRateInfo {\n        uint256 principal;\n        uint256 interest;\n        uint256 lastUpdatedTime;\n    }\n\n    event ActivePoolAddressChanged(address _activePoolAddress);\n    event BorrowerOperationsAddressChanged(address _borrowerOperationsAddress);\n    event MUSDTokenAddressChanged(address _musdTokenAddress);\n    event PCVAddressChanged(address _pcvAddress);\n    event TroveManagerAddressChanged(address _troveManagerAddress);\n\n    event InterestRateProposed(uint16 proposedRate, uint256 proposalTime);\n    event InterestRateUpdated(uint16 newInterestRate);\n    event MaxInterestRateUpdated(uint16 newMaxInterestRate);\n\n    function setAddresses(\n        address _activePoolAddress,\n        address _borrowerOperationsAddress,\n        address _musdTokenAddress,\n        address _pcvAddress,\n        address _troveManagerAddress\n    ) external;\n\n    function proposeInterestRate(uint16 _newProposedInterestRate) external;\n\n    function approveInterestRate() external;\n\n    function setMaxInterestRate(uint16 _newMaxInterestRate) external;\n\n    function addPrincipalToRate(uint16 _rate, uint256 _principal) external;\n\n    function addInterestToRate(uint16 _rate, uint256 _interest) external;\n\n    function removePrincipalFromRate(uint16 _rate, uint256 _principal) external;\n\n    function removeInterestFromRate(uint16 _rate, uint256 _interest) external;\n\n    function updateSystemInterest(uint16 _rate) external;\n\n    function updateTroveDebt(\n        uint256 _interestOwed,\n        uint256 _payment,\n        uint16 _rate\n    )\n        external\n        returns (uint256 principalAdjustment, uint256 interestAdjustment);\n\n    function interestRate() external view returns (uint16);\n\n    function getInterestRateData(\n        uint16 _rate\n    ) external view returns (InterestRateInfo memory);\n\n    function calculateDebtAdjustment(\n        uint256 _interestOwed,\n        uint256 _payment\n    )\n        external\n        pure\n        returns (uint256 principalAdjustment, uint256 interestAdjustment);\n\n    function calculateInterestOwed(\n        uint256 _principal,\n        uint16 _interestRate,\n        uint256 startTime,\n        uint256 endTime\n    ) external pure returns (uint256);\n}\n"
    },
    "contracts/interfaces/ILiquityBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.24;\n\nimport \"./IPriceFeed.sol\";\n\ninterface ILiquityBase {\n    function priceFeed() external view returns (IPriceFeed);\n}\n"
    },
    "contracts/interfaces/IPCV.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../token/IMUSD.sol\";\n\ninterface IPCV {\n    // --- Events --\n    event MUSDTokenAddressSet(address _musdTokenAddress);\n    event BorrowerOperationsAddressSet(address _borrowerOperationsAddress);\n\n    event RolesSet(address _council, address _treasury);\n    event MUSDWithdraw(address _recipient, uint256 _amount);\n    event CollateralWithdraw(address _recipient, uint256 _collateralAmount);\n    event PCVDebtPaid(uint256 _paidDebt);\n    event RecipientAdded(address _recipient);\n    event RecipientRemoved(address _recipient);\n    event PCVFeePaid(address _recipient, uint256 _amount);\n\n    // --- Functions ---\n\n    function debtToPay() external returns (uint256);\n\n    function payDebt(uint256 _musdToBurn) external;\n\n    function setAddresses(\n        address _borrowerOperations,\n        address _musdTokenAddress\n    ) external;\n\n    function initialize() external;\n\n    function setFeeRecipient(address _feeRecipient) external;\n\n    function setFeeSplit(uint8 _feeSplitPercentage) external;\n\n    function withdrawMUSD(address _recipient, uint256 _musdAmount) external;\n\n    function withdrawCollateral(\n        address _recipient,\n        uint256 _collateralAmount\n    ) external;\n\n    function addRecipientToWhitelist(address _recipient) external;\n\n    function addRecipientsToWhitelist(address[] calldata _recipients) external;\n\n    function removeRecipientFromWhitelist(address _recipient) external;\n\n    function removeRecipientsFromWhitelist(\n        address[] calldata _recipients\n    ) external;\n\n    function startChangingRoles(address _council, address _treasury) external;\n\n    function cancelChangingRoles() external;\n\n    function finalizeChangingRoles() external;\n\n    function musd() external view returns (IMUSD);\n\n    function council() external view returns (address);\n\n    function treasury() external view returns (address);\n}\n"
    },
    "contracts/interfaces/IPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.24;\n\n// Common interface for the Pools.\ninterface IPool {\n    // --- Events ---\n\n    event CollateralBalanceUpdated(uint256 _newBalance);\n\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\n    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);\n    event StabilityPoolAddressChanged(address _newStabilityPoolAddress);\n\n    event CollateralSent(address _to, uint256 _amount);\n\n    // --- Functions ---\n\n    function increaseDebt(uint256 _principal, uint256 _interest) external;\n\n    function decreaseDebt(uint256 _principal, uint256 _interest) external;\n\n    function getCollateralBalance() external view returns (uint);\n\n    function getDebt() external view returns (uint);\n\n    function getPrincipal() external view returns (uint);\n\n    function getInterest() external view returns (uint);\n}\n"
    },
    "contracts/interfaces/IPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.24;\n\ninterface IPriceFeed {\n    // --- Events ---\n    event LastGoodPriceUpdated(uint256 _lastGoodPrice);\n\n    event NewOracleRegistered(address _oracle);\n\n    // --- Function ---\n    function fetchPrice() external returns (uint);\n\n    function setOracle(address _oracle) external;\n}\n"
    },
    "contracts/interfaces/ISortedTroves.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.24;\n\n// Common interface for the SortedTroves Doubly Linked List.\ninterface ISortedTroves {\n    // --- Events ---\n\n    event BorrowerOperationsAddressChanged(address _borrowerOperationsAddress);\n    event SortedTrovesAddressChanged(address _sortedDoublyLLAddress);\n\n    event NodeAdded(address _id, uint256 _NICR);\n    event NodeRemoved(address _id);\n\n    // --- Functions ---\n\n    function setParams(\n        uint256 _size,\n        address _TroveManagerAddress,\n        address _borrowerOperationsAddress\n    ) external;\n\n    function insert(\n        address _id,\n        uint256 _NICR,\n        address _prevId,\n        address _nextId\n    ) external;\n\n    function remove(address _id) external;\n\n    function reInsert(\n        address _id,\n        uint256 _newNICR,\n        address _prevId,\n        address _nextId\n    ) external;\n\n    function contains(address _id) external view returns (bool);\n\n    function isFull() external view returns (bool);\n\n    function isEmpty() external view returns (bool);\n\n    function getSize() external view returns (uint256);\n\n    function getMaxSize() external view returns (uint256);\n\n    function getFirst() external view returns (address);\n\n    function getLast() external view returns (address);\n\n    function getNext(address _id) external view returns (address);\n\n    function getPrev(address _id) external view returns (address);\n\n    function validInsertPosition(\n        uint256 _NICR,\n        address _prevId,\n        address _nextId\n    ) external view returns (bool);\n\n    function findInsertPosition(\n        uint256 _NICR,\n        address _prevId,\n        address _nextId\n    ) external view returns (address, address);\n}\n"
    },
    "contracts/interfaces/IStabilityPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.24;\n\n/*\n * The Stability Pool holds mUSD tokens deposited by Stability Pool depositors.\n *\n * When a trove is liquidated, then depending on system conditions, some of its debt gets offset with\n * mUSD in the Stability Pool: that is, the offset debt evaporates, and an equal amount of mUSD tokens in the Stability Pool are burned.\n *\n * Thus, a liquidation causes each depositor to receive a mUSD loss in proportion to their deposit as a share of total deposits.\n * They also receive an collateral gain, as the collateral of the liquidated trove is distributed among Stability depositors\n * in the same proportion.\n *\n * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%\n * of the total mUSD in the Stability Pool, depletes 40% of each deposit.\n *\n * A deposit that has experienced a series of liquidations is termed a \"compounded deposit\": each liquidation depletes the deposit,\n * multiplying it by some factor in range ]0,1[\n *\n * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / collateral gain derivations:\n * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf\n *\n */\ninterface IStabilityPool {\n    // --- Events ---\n\n    event StabilityPoolCollateralBalanceUpdated(uint256 _newBalance);\n    event StabilityPoolMUSDBalanceUpdated(uint256 _newBalance);\n\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\n    event BorrowerOperationsAddressChanged(\n        address _newBorrowerOperationsAddress\n    );\n    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);\n    event MUSDTokenAddressChanged(address _newMUSDTokenAddress);\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\n    event SortedTrovesAddressChanged(address _newSortedTrovesAddress);\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n\n    event PUpdated(uint256 _P);\n    event SUpdated(uint256 _S, uint128 _epoch, uint128 _scale);\n    event EpochUpdated(uint128 _currentEpoch);\n    event ScaleUpdated(uint128 _currentScale);\n\n    event DepositSnapshotUpdated(\n        address indexed _depositor,\n        uint256 _P,\n        uint256 _S\n    );\n    event UserDepositChanged(address indexed _depositor, uint256 _newDeposit);\n\n    event CollateralGainWithdrawn(\n        address indexed _depositor,\n        uint256 _collateral,\n        uint256 _MUSDLoss\n    );\n    event CollateralSent(address _to, uint256 _amount);\n\n    // --- Functions ---\n\n    /*\n     * Called only once on init, to set addresses of other Liquity contracts\n     * Callable only by owner, renounces ownership at the end\n     */\n    function setAddresses(\n        address _activePoolAddress,\n        address _borrowerOperationsAddress,\n        address _musdTokenAddress,\n        address _priceFeedAddress,\n        address _sortedTrovesAddress,\n        address _troveManagerAddress\n    ) external;\n\n    /*\n     * Initial checks:\n     * - _amount is not zero\n     * ---\n     * - Sends depositor's accumulated gains (collateral) to depositor\n     */\n    function provideToSP(uint256 _amount) external;\n\n    /*\n     * Initial checks:\n     * - _amount is zero or there are no under collateralized troves left in the system\n     * - User has a non zero deposit\n     * ---\n     * - Sends all depositor's accumulated gains (collateral) to depositor\n     * - Decreases deposit stake, and takes new snapshot.\n     *\n     * If _amount > userDeposit, the user withdraws all of their compounded deposit.\n     */\n    function withdrawFromSP(uint256 _amount) external;\n\n    /*\n     * Initial checks:\n     * - User has a non zero deposit\n     * - User has an open trove\n     * - User has some collateral gain\n     * ---\n     * - Transfers the depositor's entire collateral gain from the Stability Pool to the caller's trove\n     * - Leaves their compounded deposit in the Stability Pool\n     * - Updates snapshots for deposit\n     */\n    function withdrawCollateralGainToTrove(\n        address _upperHint,\n        address _lowerHint\n    ) external;\n\n    /*\n     * Initial checks:\n     * - Caller is TroveManager\n     * ---\n     * Cancels out the specified debt against the mUSD contained in the Stability Pool (as far as possible)\n     * and transfers the Trove's collateral from ActivePool to StabilityPool.\n     * Only called by liquidation functions in the TroveManager.\n     */\n    function offset(uint256 _debt, uint256 _coll) external;\n\n    /*\n     * Returns the total amount of collateral held by the pool, accounted in an internal variable instead of `balance`,\n     * to exclude edge cases like collateral received from a self-destruct.\n     */\n    function getCollateralBalance() external view returns (uint);\n\n    /*\n     * Returns mUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.\n     */\n    function getTotalMUSDDeposits() external view returns (uint);\n\n    /*\n     * Calculates the collateral gain earned by the deposit since its last snapshots were taken.\n     */\n    function getDepositorCollateralGain(\n        address _depositor\n    ) external view returns (uint);\n\n    /*\n     * Return the user's compounded deposit.\n     */\n    function getCompoundedMUSDDeposit(\n        address _depositor\n    ) external view returns (uint);\n}\n"
    },
    "contracts/interfaces/ITroveManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.24;\n\nimport \"./IStabilityPool.sol\";\nimport \"./IPCV.sol\";\n\n// Common interface for the Trove Manager.\ninterface ITroveManager {\n    enum Status {\n        nonExistent,\n        active,\n        closedByOwner,\n        closedByLiquidation,\n        closedByRedemption\n    }\n\n    struct InterestRateChange {\n        uint16 interestRate;\n        uint256 blockNumber;\n    }\n\n    // --- Events ---\n\n    event ActivePoolAddressChanged(address _activePoolAddress);\n    event BorrowerOperationsAddressChanged(\n        address _newBorrowerOperationsAddress\n    );\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\n    event GasPoolAddressChanged(address _gasPoolAddress);\n    event InterestRateManagerAddressChanged(\n        address _interestRateManagerAddress\n    );\n    event MUSDTokenAddressChanged(address _newMUSDTokenAddress);\n    event PCVAddressChanged(address _pcvAddress);\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\n\n    event Liquidation(\n        uint256 _liquidatedPrincipal,\n        uint256 _liquidatedInterest,\n        uint256 _liquidatedColl,\n        uint256 _collGasCompensation,\n        uint256 _gasCompensation\n    );\n    event Redemption(\n        uint256 _attemptedAmount,\n        uint256 _actualAmount,\n        uint256 _collateralSent,\n        uint256 _collateralFee\n    );\n    event TroveUpdated(\n        address indexed _borrower,\n        uint256 _principal,\n        uint256 _interest,\n        uint256 _coll,\n        uint256 stake,\n        uint8 operation\n    );\n    event TroveLiquidated(\n        address indexed _borrower,\n        uint256 _debt,\n        uint256 _coll,\n        uint8 operation\n    );\n    event BaseRateUpdated(uint256 _baseRate);\n    event LastFeeOpTimeUpdated(uint256 _lastFeeOpTime);\n    event TotalStakesUpdated(uint256 _newTotalStakes);\n    event SystemSnapshotsUpdated(\n        uint256 _totalStakesSnapshot,\n        uint256 _totalCollateralSnapshot\n    );\n    event LTermsUpdated(\n        uint256 _L_Collateral,\n        uint256 _L_Principal,\n        uint256 _L_Interest\n    );\n    event TroveSnapshotsUpdated(\n        uint256 _L_Collateral,\n        uint256 _L_Principal,\n        uint256 _L_Interest\n    );\n    event TroveIndexUpdated(address _borrower, uint256 _newIndex);\n\n    // --- Functions ---\n\n    function setAddresses(\n        address _activePoolAddress,\n        address _borrowerOperationsAddress,\n        address _collSurplusPoolAddress,\n        address _defaultPoolAddress,\n        address _gasPoolAddress,\n        address _interestRateManagerAddress,\n        address _musdTokenAddress,\n        address _pcvAddress,\n        address _priceFeedAddress,\n        address _sortedTrovesAddress,\n        address _stabilityPoolAddress\n    ) external;\n\n    function liquidate(address _borrower) external;\n\n    function batchLiquidateTroves(address[] calldata _troveArray) external;\n\n    function redeemCollateral(\n        uint256 _amount,\n        address _firstRedemptionHint,\n        address _upperPartialRedemptionHint,\n        address _lowerPartialRedemptionHint,\n        uint256 _partialRedemptionHintNICR,\n        uint256 _maxIterations,\n        uint256 _maxFeePercentage\n    ) external;\n\n    function updateStakeAndTotalStakes(\n        address _borrower\n    ) external returns (uint);\n\n    function updateTroveRewardSnapshots(address _borrower) external;\n\n    function addTroveOwnerToArray(\n        address _borrower\n    ) external returns (uint256 index);\n\n    function applyPendingRewards(address _borrower) external;\n\n    function closeTrove(address _borrower) external;\n\n    function removeStake(address _borrower) external;\n\n    function decayBaseRateFromBorrowing() external;\n\n    function setTroveStatus(address _borrower, Status _status) external;\n\n    function setTroveMaxBorrowingCapacity(\n        address _borrower,\n        uint256 _maxBorrowingCapacity\n    ) external;\n\n    function updateDefaultPoolInterest() external;\n\n    function updateSystemAndTroveInterest(address _borrower) external;\n\n    function increaseTroveColl(\n        address _borrower,\n        uint256 _collIncrease\n    ) external returns (uint);\n\n    function decreaseTroveColl(\n        address _borrower,\n        uint256 _collDecrease\n    ) external returns (uint);\n\n    function increaseTroveDebt(\n        address _borrower,\n        uint256 _debtIncrease\n    ) external returns (uint256);\n\n    function decreaseTroveDebt(\n        address _borrower,\n        uint256 _debtDecrease\n    ) external returns (uint256, uint256);\n\n    function setTroveInterestRate(address _borrower, uint16 _rate) external;\n\n    function setTroveLastInterestUpdateTime(\n        address _borrower,\n        uint256 _timestamp\n    ) external;\n\n    function stabilityPool() external view returns (IStabilityPool);\n\n    function pcv() external view returns (IPCV);\n\n    function getTroveOwnersCount() external view returns (uint);\n\n    function getTroveFromTroveOwnersArray(\n        uint256 _index\n    ) external view returns (address);\n\n    function getTroveInterestOwed(\n        address _borrower\n    ) external view returns (uint256);\n\n    function getTrovePrincipal(address _borrower) external view returns (uint);\n\n    function getNominalICR(address _borrower) external view returns (uint);\n\n    function getCurrentICR(\n        address _borrower,\n        uint256 _price\n    ) external view returns (uint);\n\n    function getPendingCollateral(\n        address _borrower\n    ) external view returns (uint);\n\n    function getPendingDebt(\n        address _borrower\n    ) external view returns (uint256, uint256);\n\n    function hasPendingRewards(address _borrower) external view returns (bool);\n\n    function getEntireDebtAndColl(\n        address _borrower\n    )\n        external\n        view\n        returns (\n            uint256 coll,\n            uint256 principal,\n            uint256 interest,\n            uint256 pendingCollateral,\n            uint256 pendingPrincipal,\n            uint256 pendingInterest\n        );\n\n    function getRedemptionRate() external view returns (uint);\n\n    function getRedemptionRateWithDecay() external view returns (uint);\n\n    function getRedemptionFeeWithDecay(\n        uint256 _collateralDrawn\n    ) external view returns (uint);\n\n    function getBorrowingRate() external view returns (uint);\n\n    function getBorrowingRateWithDecay() external view returns (uint);\n\n    function getBorrowingFee(uint256 _debt) external view returns (uint);\n\n    function getBorrowingFeeWithDecay(\n        uint256 _debt\n    ) external view returns (uint);\n\n    function getTroveStatus(address _borrower) external view returns (Status);\n\n    function getTroveStake(address _borrower) external view returns (uint);\n\n    function getTroveDebt(address _borrower) external view returns (uint);\n\n    function getTroveInterestRate(\n        address _borrower\n    ) external view returns (uint16);\n\n    function getTroveLastInterestUpdateTime(\n        address _borrower\n    ) external view returns (uint);\n\n    function getTroveColl(address _borrower) external view returns (uint);\n\n    function getTCR(uint256 _price) external view returns (uint);\n\n    function checkRecoveryMode(uint256 _price) external view returns (bool);\n}\n"
    },
    "contracts/PCV.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.24;\n\nimport \"./BorrowerOperations.sol\";\nimport \"./dependencies/CheckContract.sol\";\nimport \"./dependencies/SendCollateral.sol\";\nimport \"./interfaces/IPCV.sol\";\nimport \"./token/IMUSD.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract PCV is IPCV, Ownable, CheckContract, SendCollateral {\n    uint256 public constant BOOTSTRAP_LOAN = 1e26; // 100M mUSD\n\n    uint256 public immutable governanceTimeDelay;\n\n    BorrowerOperations public borrowerOperations;\n    IMUSD public musd;\n\n    // TODO ideal initialization in constructor/setAddresses\n    uint256 public debtToPay;\n    bool public isInitialized;\n\n    address public council;\n    address public treasury;\n\n    mapping(address => bool) public recipientsWhitelist;\n\n    address public pendingCouncilAddress;\n    address public pendingTreasuryAddress;\n    uint256 public changingRolesInitiated;\n\n    address public feeRecipient;\n    uint8 public feeSplitPercentage; // percentage of fees to be sent to feeRecipient\n    uint8 public constant FEE_SPLIT_MAX = 50; // no more than 50% of fees can be sent until the debt is paid\n\n    modifier onlyAfterDebtPaid() {\n        require(isInitialized && debtToPay == 0, \"PCV: debt must be paid\");\n        _;\n    }\n\n    modifier onlyOwnerOrCouncilOrTreasury() {\n        require(\n            msg.sender == owner() ||\n                msg.sender == council ||\n                msg.sender == treasury,\n            \"PCV: caller must be owner or council or treasury\"\n        );\n        _;\n    }\n\n    modifier onlyWhitelistedRecipient(address _recipient) {\n        require(\n            recipientsWhitelist[_recipient],\n            \"PCV: recipient must be in whitelist\"\n        );\n        _;\n    }\n\n    constructor(uint256 _governanceTimeDelay) Ownable(msg.sender) {\n        governanceTimeDelay = _governanceTimeDelay;\n        require(governanceTimeDelay <= 30 weeks, \"Governance delay is too big\");\n    }\n\n    receive() external payable {}\n\n    function payDebt(\n        uint256 _musdToBurn\n    ) external override onlyOwnerOrCouncilOrTreasury {\n        require(\n            debtToPay > 0 || feeRecipient != address(0),\n            \"PCV: debt has already paid\"\n        );\n        require(\n            _musdToBurn <= musd.balanceOf(address(this)),\n            \"PCV: not enough tokens\"\n        );\n\n        // if the debt has already been paid, the feeRecipient should receive all fees\n        if (debtToPay == 0) {\n            feeSplitPercentage = 100;\n        }\n\n        uint256 feeToRecipient = (_musdToBurn * feeSplitPercentage) / 100;\n        uint256 feeToDebt = _musdToBurn - feeToRecipient;\n\n        if (feeToDebt > debtToPay) {\n            feeToRecipient += feeToDebt - debtToPay;\n            feeToDebt = debtToPay;\n        }\n\n        debtToPay -= feeToDebt;\n\n        if (feeRecipient != address(0) && feeSplitPercentage > 0) {\n            require(\n                musd.transfer(feeRecipient, feeToRecipient),\n                \"PCV: sending mUSD failed\"\n            );\n        }\n        borrowerOperations.burnDebtFromPCV(feeToDebt);\n\n        // slither-disable-next-line reentrancy-events\n        emit PCVDebtPaid(feeToDebt);\n        emit PCVFeePaid(feeRecipient, feeToRecipient);\n    }\n\n    function setAddresses(\n        address _borrowerOperations,\n        address _musdTokenAddress\n    ) external override onlyOwner {\n        require(address(musd) == address(0), \"PCV: contacts already set\");\n\n        checkContract(_borrowerOperations);\n        checkContract(_musdTokenAddress);\n\n        // slither-disable-start missing-zero-check\n        borrowerOperations = BorrowerOperations(_borrowerOperations);\n        musd = IMUSD(_musdTokenAddress);\n        // slither-disable-end missing-zero-check\n\n        emit BorrowerOperationsAddressSet(_borrowerOperations);\n        emit MUSDTokenAddressSet(_musdTokenAddress);\n    }\n\n    function initialize() external override onlyOwnerOrCouncilOrTreasury {\n        require(!isInitialized, \"PCV: already initialized\");\n\n        debtToPay = BOOTSTRAP_LOAN;\n        isInitialized = true;\n        borrowerOperations.mintBootstrapLoanFromPCV(BOOTSTRAP_LOAN);\n        depositToStabilityPool(BOOTSTRAP_LOAN);\n    }\n\n    function setFeeRecipient(\n        address _feeRecipient\n    ) external onlyOwnerOrCouncilOrTreasury {\n        require(\n            _feeRecipient != address(0),\n            \"PCV: Fee recipient cannot be the zero address.\"\n        );\n        feeRecipient = _feeRecipient;\n    }\n\n    function setFeeSplit(\n        uint8 _feeSplitPercentage\n    ) external onlyOwnerOrCouncilOrTreasury {\n        require(\n            debtToPay > 0,\n            \"PCV: Must have debt in order to set a fee split.\"\n        );\n        require(\n            _feeSplitPercentage <= FEE_SPLIT_MAX,\n            \"PCV: Fee split must be at most 50 while debt remains.\"\n        );\n        feeSplitPercentage = _feeSplitPercentage;\n    }\n\n    function withdrawMUSD(\n        address _recipient,\n        uint256 _amount\n    )\n        external\n        override\n        onlyAfterDebtPaid\n        onlyOwnerOrCouncilOrTreasury\n        onlyWhitelistedRecipient(_recipient)\n    {\n        require(\n            _amount <= musd.balanceOf(address(this)),\n            \"PCV: not enough tokens\"\n        );\n        require(musd.transfer(_recipient, _amount), \"PCV: sending mUSD failed\");\n        // slither-disable-next-line reentrancy-events\n        emit MUSDWithdraw(_recipient, _amount);\n    }\n\n    function withdrawCollateral(\n        address _recipient,\n        uint256 _collateralAmount\n    )\n        external\n        override\n        onlyAfterDebtPaid\n        onlyOwnerOrCouncilOrTreasury\n        onlyWhitelistedRecipient(_recipient)\n    {\n        emit CollateralWithdraw(_recipient, _collateralAmount);\n        _sendCollateral(_recipient, _collateralAmount);\n    }\n\n    function addRecipientsToWhitelist(\n        address[] calldata _recipients\n    ) external override onlyOwner {\n        require(\n            _recipients.length > 0,\n            \"PCV: Recipients array must not be empty\"\n        );\n        for (uint256 i = 0; i < _recipients.length; i++) {\n            addRecipientToWhitelist(_recipients[i]);\n        }\n    }\n\n    function removeRecipientsFromWhitelist(\n        address[] calldata _recipients\n    ) external override onlyOwner {\n        require(\n            _recipients.length > 0,\n            \"PCV: Recipients array must not be empty\"\n        );\n        for (uint256 i = 0; i < _recipients.length; i++) {\n            removeRecipientFromWhitelist(_recipients[i]);\n        }\n    }\n\n    function startChangingRoles(\n        address _council,\n        address _treasury\n    ) external override onlyOwner {\n        require(\n            _council != council || _treasury != treasury,\n            \"PCV: these roles already set\"\n        );\n\n        // solhint-disable-next-line not-rely-on-time\n        changingRolesInitiated = block.timestamp;\n        if (council == address(0) && treasury == address(0)) {\n            // solhint-disable-next-line not-rely-on-time\n            changingRolesInitiated -= governanceTimeDelay; // skip delay if no roles set\n        }\n        pendingCouncilAddress = _council;\n        pendingTreasuryAddress = _treasury;\n    }\n\n    function cancelChangingRoles() external override onlyOwner {\n        require(changingRolesInitiated != 0, \"PCV: Change not initiated\");\n\n        changingRolesInitiated = 0;\n        pendingCouncilAddress = address(0);\n        pendingTreasuryAddress = address(0);\n    }\n\n    function finalizeChangingRoles() external override onlyOwner {\n        require(changingRolesInitiated > 0, \"PCV: Change not initiated\");\n        require(\n            // solhint-disable-next-line not-rely-on-time\n            block.timestamp >= changingRolesInitiated + governanceTimeDelay,\n            \"PCV: Governance delay has not elapsed\"\n        );\n\n        council = pendingCouncilAddress;\n        treasury = pendingTreasuryAddress;\n        emit RolesSet(council, treasury);\n\n        changingRolesInitiated = 0;\n        pendingCouncilAddress = address(0);\n        pendingTreasuryAddress = address(0);\n    }\n\n    function addRecipientToWhitelist(\n        address _recipient\n    ) public override onlyOwner {\n        require(\n            !recipientsWhitelist[_recipient],\n            \"PCV: Recipient has already been added to whitelist\"\n        );\n        recipientsWhitelist[_recipient] = true;\n        emit RecipientAdded(_recipient);\n    }\n\n    function removeRecipientFromWhitelist(\n        address _recipient\n    ) public override onlyOwner {\n        require(\n            recipientsWhitelist[_recipient],\n            \"PCV: Recipient is not in whitelist\"\n        );\n        recipientsWhitelist[_recipient] = false;\n        emit RecipientRemoved(_recipient);\n    }\n\n    function depositToStabilityPool(\n        uint256 _amount\n    ) public onlyOwnerOrCouncilOrTreasury {\n        require(\n            _amount <= musd.balanceOf(address(this)),\n            \"PCV: not enough tokens\"\n        );\n        require(\n            musd.approve(borrowerOperations.stabilityPoolAddress(), _amount),\n            \"PCV: Approval failed\"\n        );\n        IStabilityPool(borrowerOperations.stabilityPoolAddress()).provideToSP(\n            _amount\n        );\n\n        // TODO Emit event\n    }\n}\n"
    },
    "contracts/SortedTroves.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.24;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./dependencies/CheckContract.sol\";\nimport \"./interfaces/ISortedTroves.sol\";\nimport \"./interfaces/ITroveManager.sol\";\n\n/*\n * A sorted doubly linked list with nodes sorted in descending order.\n *\n * Nodes map to active Troves in the system - the ID property is the address of a Trove owner.\n * Nodes are ordered according to their current nominal individual collateral ratio (NICR),\n * which is like the ICR but without the price, i.e., just collateral / debt.\n *\n * The list optionally accepts insert position hints.\n *\n * NICRs are computed dynamically at runtime, and not stored on the Node. This is because NICRs of active Troves\n * change dynamically as liquidation events occur.\n *\n * The list relies on the fact that liquidation events preserve ordering: a liquidation decreases the NICRs of all active Troves,\n * but maintains their order. A node inserted based on current NICR will maintain the correct position,\n * relative to it's peers, as rewards accumulate, as long as it's raw collateral and debt have not changed.\n * Thus, Nodes remain sorted by current NICR.\n *\n * Nodes need only be re-inserted upon a Trove operation - when the owner adds or removes collateral or debt\n * to their position.\n *\n * The list is a modification of the following audited SortedDoublyLinkedList:\n * https://github.com/livepeer/protocol/blob/master/contracts/libraries/SortedDoublyLL.sol\n *\n *\n * Changes made in the Liquity implementation:\n *\n * - Keys have been removed from nodes\n *\n * - Ordering checks for insertion are performed by comparing an NICR argument to the current NICR, calculated at runtime.\n *   The list relies on the property that ordering by ICR is maintained as the collateral:USD price varies.\n *\n * - Public functions with parameters have been made internal to save gas, and given an external wrapper function for external access\n */\ncontract SortedTroves is Ownable, CheckContract, ISortedTroves {\n    // Information for a node in the list\n    struct Node {\n        bool exists;\n        address nextId; // Id of next node (smaller NICR) in the list\n        address prevId; // Id of previous node (larger NICR) in the list\n    }\n\n    // Information for the list\n    struct Data {\n        address head; // Head of the list. Also the node in the list with the largest NICR\n        address tail; // Tail of the list. Also the node in the list with the smallest NICR\n        uint256 maxSize; // Maximum size of the list\n        uint256 size; // Current size of the list\n        mapping(address => Node) nodes; // Track the corresponding ids for each node in the list\n    }\n\n    address public borrowerOperationsAddress;\n    ITroveManager public troveManager;\n    Data public data;\n\n    event TroveManagerAddressChanged(address _troveManagerAddress);\n\n    constructor() Ownable(msg.sender) {}\n\n    // --- Dependency setters ---\n\n    function setParams(\n        uint256 _size,\n        address _borrowerOperationsAddress,\n        address _troveManagerAddress\n    ) external override onlyOwner {\n        require(_size > 0, \"SortedTroves: Size cant be zero\");\n        checkContract(_troveManagerAddress);\n        checkContract(_borrowerOperationsAddress);\n\n        data.maxSize = _size;\n\n        // slither-disable-next-line missing-zero-check\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n        troveManager = ITroveManager(_troveManagerAddress);\n\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n\n        renounceOwnership();\n    }\n\n    function insert(\n        address _id,\n        uint256 _NICR,\n        address _prevId,\n        address _nextId\n    ) external override {\n        ITroveManager troveManagerCached = troveManager;\n\n        _requireCallerIsBOorTroveM(troveManagerCached);\n        _insert(troveManagerCached, _id, _NICR, _prevId, _nextId);\n    }\n\n    function remove(address _id) external override {\n        _requireCallerIsTroveManager();\n        _remove(_id);\n    }\n\n    /*\n     * @dev Re-insert the node at a new position, based on its new NICR\n     * @param _id Node's id\n     * @param _newNICR Node's new NICR\n     * @param _prevId Id of previous node for the new insert position\n     * @param _nextId Id of next node for the new insert position\n     */\n    function reInsert(\n        address _id,\n        uint256 _newNICR,\n        address _prevId,\n        address _nextId\n    ) external override {\n        ITroveManager troveManagerCached = troveManager;\n\n        _requireCallerIsBOorTroveM(troveManagerCached);\n        // List must contain the node\n        require(contains(_id), \"SortedTroves: List does not contain the id\");\n        // NICR must be non-zero\n        require(_newNICR > 0, \"SortedTroves: NICR must be positive\");\n\n        // Remove node from the list\n        _remove(_id);\n\n        _insert(troveManagerCached, _id, _newNICR, _prevId, _nextId);\n    }\n\n    /*\n     * @dev Returns the current size of the list\n     */\n    function getSize() external view override returns (uint256) {\n        return data.size;\n    }\n\n    /*\n     * @dev Returns the maximum size of the list\n     */\n    function getMaxSize() external view override returns (uint256) {\n        return data.maxSize;\n    }\n\n    /*\n     * @dev Returns the first node in the list (node with the largest NICR)\n     */\n    function getFirst() external view override returns (address) {\n        return data.head;\n    }\n\n    /*\n     * @dev Returns the last node in the list (node with the smallest NICR)\n     */\n    function getLast() external view override returns (address) {\n        return data.tail;\n    }\n\n    /*\n     * @dev Returns the next node (with a smaller NICR) in the list for a given node\n     * @param _id Node's id\n     */\n    function getNext(address _id) external view override returns (address) {\n        return data.nodes[_id].nextId;\n    }\n\n    /*\n     * @dev Returns the previous node (with a larger NICR) in the list for a given node\n     * @param _id Node's id\n     */\n    function getPrev(address _id) external view override returns (address) {\n        return data.nodes[_id].prevId;\n    }\n\n    /*\n     * @dev Find the insert position for a new node with the given NICR\n     * @param _NICR Node's NICR\n     * @param _prevId Id of previous node for the insert position\n     * @param _nextId Id of next node for the insert position\n     */\n    function findInsertPosition(\n        uint256 _NICR,\n        address _prevId,\n        address _nextId\n    ) external view override returns (address, address) {\n        return _findInsertPosition(troveManager, _NICR, _prevId, _nextId);\n    }\n\n    /*\n     * @dev Check if a pair of nodes is a valid insertion point for a new node with the given NICR\n     * @param _NICR Node's NICR\n     * @param _prevId Id of previous node for the insert position\n     * @param _nextId Id of next node for the insert position\n     */\n    function validInsertPosition(\n        uint256 _NICR,\n        address _prevId,\n        address _nextId\n    ) external view override returns (bool) {\n        return _validInsertPosition(troveManager, _NICR, _prevId, _nextId);\n    }\n\n    /*\n     * @dev Checks if the list contains a node\n     */\n    function contains(address _id) public view override returns (bool) {\n        return data.nodes[_id].exists;\n    }\n\n    /*\n     * @dev Checks if the list is full\n     */\n    function isFull() public view override returns (bool) {\n        return data.size == data.maxSize;\n    }\n\n    /*\n     * @dev Checks if the list is empty\n     */\n    function isEmpty() public view override returns (bool) {\n        return data.size == 0;\n    }\n\n    /*\n     * @dev Remove a node from the list\n     * @param _id Node's id\n     */\n    function _remove(address _id) internal {\n        // List must contain the node\n        require(contains(_id), \"SortedTroves: List does not contain the id\");\n\n        if (data.size > 1) {\n            // List contains more than a single node\n            if (_id == data.head) {\n                // The removed node is the head\n                // Set head to next node\n                data.head = data.nodes[_id].nextId;\n                // Set prev pointer of new head to null\n                data.nodes[data.head].prevId = address(0);\n            } else if (_id == data.tail) {\n                // The removed node is the tail\n                // Set tail to previous node\n                data.tail = data.nodes[_id].prevId;\n                // Set next pointer of new tail to null\n                data.nodes[data.tail].nextId = address(0);\n            } else {\n                // The removed node is neither the head nor the tail\n                // Set next pointer of previous node to the next node\n                data.nodes[data.nodes[_id].prevId].nextId = data\n                    .nodes[_id]\n                    .nextId;\n                // Set prev pointer of next node to the previous node\n                data.nodes[data.nodes[_id].nextId].prevId = data\n                    .nodes[_id]\n                    .prevId;\n            }\n        } else {\n            // List contains a single node\n            // Set the head and tail to null\n            data.head = address(0);\n            data.tail = address(0);\n        }\n\n        delete data.nodes[_id];\n        data.size -= 1;\n        emit NodeRemoved(_id);\n    }\n\n    function _insert(\n        ITroveManager _troveManager,\n        address _id,\n        uint256 _NICR,\n        address _prevId,\n        address _nextId\n    ) internal {\n        // List must not be full\n        require(!isFull(), \"SortedTroves: List is full\");\n        // List must not already contain node\n        require(!contains(_id), \"SortedTroves: List already contains the node\");\n        // Node id must not be null\n        require(_id != address(0), \"SortedTroves: Id cannot be zero\");\n        // NICR must be non-zero\n        require(_NICR > 0, \"SortedTroves: NICR must be positive\");\n\n        address prevId = _prevId;\n        address nextId = _nextId;\n\n        if (!_validInsertPosition(_troveManager, _NICR, prevId, nextId)) {\n            // Sender's hint was not a valid insert position\n            // Use sender's hint to find a valid insert position\n            (prevId, nextId) = _findInsertPosition(\n                _troveManager,\n                _NICR,\n                prevId,\n                nextId\n            );\n        }\n\n        data.nodes[_id].exists = true;\n\n        if (prevId == address(0) && nextId == address(0)) {\n            // Insert as head and tail\n            data.head = _id;\n            data.tail = _id;\n        } else if (prevId == address(0)) {\n            // Insert before `prevId` as the head\n            data.nodes[_id].nextId = data.head;\n            data.nodes[data.head].prevId = _id;\n            data.head = _id;\n        } else if (nextId == address(0)) {\n            // Insert after `nextId` as the tail\n            data.nodes[_id].prevId = data.tail;\n            data.nodes[data.tail].nextId = _id;\n            data.tail = _id;\n        } else {\n            // Insert at insert position between `prevId` and `nextId`\n            data.nodes[_id].nextId = nextId;\n            data.nodes[_id].prevId = prevId;\n            data.nodes[prevId].nextId = _id;\n            data.nodes[nextId].prevId = _id;\n        }\n\n        data.size += 1;\n        emit NodeAdded(_id, _NICR);\n    }\n\n    /*\n     * @dev Descend the list (larger NICRs to smaller NICRs) to find a valid insert position\n     * @param _troveManager TroveManager contract, passed in as param to save SLOAD’s\n     * @param _NICR Node's NICR\n     * @param _startId Id of node to start descending the list from\n     */\n    function _descendList(\n        ITroveManager _troveManager,\n        uint256 _NICR,\n        address _startId\n    ) internal view returns (address, address) {\n        // If `_startId` is the head, check if the insert position is before the head\n        if (\n            data.head == _startId &&\n            _NICR >= _troveManager.getNominalICR(_startId)\n        ) {\n            return (address(0), _startId);\n        }\n\n        address prevId = _startId;\n        address nextId = data.nodes[prevId].nextId;\n\n        // Descend the list until we reach the end or until we find a valid insert position\n        while (\n            prevId != address(0) &&\n            !_validInsertPosition(_troveManager, _NICR, prevId, nextId)\n        ) {\n            prevId = data.nodes[prevId].nextId;\n            nextId = data.nodes[prevId].nextId;\n        }\n\n        return (prevId, nextId);\n    }\n\n    /*\n     * @dev Ascend the list (smaller NICRs to larger NICRs) to find a valid insert position\n     * @param _troveManager TroveManager contract, passed in as param to save SLOAD’s\n     * @param _NICR Node's NICR\n     * @param _startId Id of node to start ascending the list from\n     */\n    function _ascendList(\n        ITroveManager _troveManager,\n        uint256 _NICR,\n        address _startId\n    ) internal view returns (address, address) {\n        // If `_startId` is the tail, check if the insert position is after the tail\n        if (\n            data.tail == _startId &&\n            _NICR <= _troveManager.getNominalICR(_startId)\n        ) {\n            return (_startId, address(0));\n        }\n\n        address nextId = _startId;\n        address prevId = data.nodes[nextId].prevId;\n\n        // Ascend the list until we reach the end or until we find a valid insertion point\n        while (\n            nextId != address(0) &&\n            !_validInsertPosition(_troveManager, _NICR, prevId, nextId)\n        ) {\n            nextId = data.nodes[nextId].prevId;\n            prevId = data.nodes[nextId].prevId;\n        }\n\n        return (prevId, nextId);\n    }\n\n    /*\n     * @dev Find the insert position for a new node with the given NICR\n     * @param _NICR Node's NICR\n     * @param _prevId Id of previous node for the insert position\n     * @param _nextId Id of next node for the insert position\n     */\n    function _findInsertPosition(\n        ITroveManager _troveManager,\n        uint256 _NICR,\n        address _prevId,\n        address _nextId\n    ) internal view returns (address, address) {\n        address prevId = _prevId;\n        address nextId = _nextId;\n\n        if (prevId != address(0)) {\n            if (\n                !contains(prevId) || _NICR > _troveManager.getNominalICR(prevId)\n            ) {\n                // `prevId` does not exist anymore or now has a smaller NICR than the given NICR\n                prevId = address(0);\n            }\n        }\n\n        if (nextId != address(0)) {\n            if (\n                !contains(nextId) || _NICR < _troveManager.getNominalICR(nextId)\n            ) {\n                // `nextId` does not exist anymore or now has a larger NICR than the given NICR\n                nextId = address(0);\n            }\n        }\n\n        if (prevId == address(0) && nextId == address(0)) {\n            // No hint - descend list starting from head\n            return _descendList(_troveManager, _NICR, data.head);\n        } else if (prevId == address(0)) {\n            // No `prevId` for hint - ascend list starting from `nextId`\n            return _ascendList(_troveManager, _NICR, nextId);\n        } else if (nextId == address(0)) {\n            // No `nextId` for hint - descend list starting from `prevId`\n            return _descendList(_troveManager, _NICR, prevId);\n        } else {\n            // Descend list starting from `prevId`\n            return _descendList(_troveManager, _NICR, prevId);\n        }\n    }\n\n    function _validInsertPosition(\n        ITroveManager _troveManager,\n        uint256 _NICR,\n        address _prevId,\n        address _nextId\n    ) internal view returns (bool) {\n        if (_prevId == address(0) && _nextId == address(0)) {\n            // `(null, null)` is a valid insert position if the list is empty\n            return isEmpty();\n        } else if (_prevId == address(0)) {\n            // `(null, _nextId)` is a valid insert position if `_nextId` is the head of the list\n            return\n                data.head == _nextId &&\n                _NICR >= _troveManager.getNominalICR(_nextId);\n        } else if (_nextId == address(0)) {\n            // `(_prevId, null)` is a valid insert position if `_prevId` is the tail of the list\n            return\n                data.tail == _prevId &&\n                _NICR <= _troveManager.getNominalICR(_prevId);\n        } else {\n            // `(_prevId, _nextId)` is a valid insert position if they are adjacent nodes and `_NICR` falls between the two nodes' NICRs\n            return\n                data.nodes[_prevId].nextId == _nextId &&\n                _troveManager.getNominalICR(_prevId) >= _NICR &&\n                _NICR >= _troveManager.getNominalICR(_nextId);\n        }\n    }\n\n    // --- 'require' functions ---\n    function _requireCallerIsTroveManager() internal view {\n        require(\n            msg.sender == address(troveManager),\n            \"SortedTroves: Caller is not the TroveManager\"\n        );\n    }\n\n    function _requireCallerIsBOorTroveM(\n        ITroveManager _troveManager\n    ) internal view {\n        require(\n            msg.sender == borrowerOperationsAddress ||\n                msg.sender == address(_troveManager),\n            \"SortedTroves: Caller is neither BO nor TroveM\"\n        );\n    }\n}\n"
    },
    "contracts/token/IMUSD.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\";\n\ninterface IMUSD is IERC20Metadata, IERC20Permit {\n    // --- Events ---\n    event BorrowerOperationsAddressAdded(address _newBorrowerOperationsAddress);\n    event BalanceUpdated(address _user, uint256 _amount);\n    event InterestRateManagerAddressAdded(address _interestRateManagerAddress);\n    event StabilityPoolAddressAdded(address _newStabilityPoolAddress);\n    event TroveManagerAddressAdded(address _troveManagerAddress);\n\n    // --- Governance Functions ---\n    function cancelAddContracts() external;\n\n    function cancelAddMintList() external;\n\n    function cancelRevokeBurnList() external;\n\n    function cancelRevokeMintList() external;\n\n    function startAddContracts(\n        address _troveManagerAddress,\n        address _stabilityPoolAddress,\n        address _borrowerOperationsAddress,\n        address _interestRateManagerAddress\n    ) external;\n\n    function startAddMintList(address _account) external;\n\n    function startRevokeBurnList(address _account) external;\n\n    function startRevokeMintList(address _account) external;\n\n    function finalizeAddContracts() external;\n\n    function finalizeAddMintList() external;\n\n    function finalizeRevokeBurnList() external;\n\n    function finalizeRevokeMintList() external;\n\n    // --- External Functions ---\n    function burn(address _account, uint256 _amount) external;\n\n    function mint(address _account, uint256 _amount) external;\n\n    function burnList(address contractAddress) external view returns (bool);\n\n    function mintList(address contractAddress) external view returns (bool);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 100
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}